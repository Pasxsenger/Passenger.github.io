<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[TOEFL Writing:Education]]></title>
    <url>%2F2019%2F11%2F10%2FTOEFL-Writing-Education%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1003 Emergency]]></title>
    <url>%2F2019%2F11%2F09%2FPTA-Advanced-Level-1003-Emergency%2F</url>
    <content type="text"><![CDATA[As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:12 4 Solution:注意： 1.题目要求的是最短路的条数而不是长度 2.memset的用法：将每个字节赋相同值（0x） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 99999#define Ncity 501#define Nroad 10000using namespace std;int rescue[Ncity], map[Ncity][Ncity], dis[Nroad], vis[Ncity] = &#123; 0 &#125;, maxteam[Ncity], way[Ncity];int main() &#123; int N, M, C1, C2; int i, j, k, u, minn; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;C1, &amp;C2); //memset(map, INF, sizeof(map)); //初始化地图 for (i = 0; i &lt; N; i++) &#123; for (j = 0; j &lt; N; j++) &#123; map[i][j] = INF; &#125; &#125; for (i = 0; i &lt; N; i++) //输入各城市救援队数量 scanf("%d", &amp;rescue[i]); for (i = 0; i &lt; M; i++) &#123; //输入路径 scanf("%d%d", &amp;j, &amp;k); scanf("%d", &amp;map[j][k]); map[k][j] = map[j][k]; &#125; for (i = 0; i &lt; N; i++) &#123; dis[i] = map[C1][i]; maxteam[i] = rescue[i]; way[i] = 1; if (dis[i] != INF &amp;&amp; i != C1) &#123; maxteam[i] += rescue[C1]; &#125; &#125; vis[C1] = 1; //标记起点 for (i = 1; i &lt; N; i++) &#123; //Dijkstra minn = INF; for (j = 0; j &lt; N; j++) &#123; if (vis[j] == 0 &amp;&amp; dis[j] &lt; minn) &#123; minn = dis[j]; u = j; &#125; &#125; vis[u] = 1; //标记u for (k = 0; k &lt; N; k++) &#123; //松弛u if (map[u][k] &lt; INF &amp;&amp; vis[k] == 0) &#123; //沿着一条路走 if (dis[k] &gt; dis[u] + map[u][k]) &#123; dis[k] = dis[u] + map[u][k]; maxteam[k] = maxteam[u] + rescue[k]; way[k] = way[u]; &#125; else if (dis[k] == dis[u] + map[u][k]) &#123; //出现了另一条路 way[k] += way[u]; if (maxteam[k] &lt; maxteam[u] + rescue[k]) &#123; maxteam[k] = maxteam[u] + rescue[k]; &#125; &#125; &#125; &#125; &#125; printf("%d %d", way[C2], maxteam[C2]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1002 A+B for Polynomials]]></title>
    <url>%2F2019%2F11%2F08%2FPTA-Advanced-Level-1002-A-B-for-Polynomials%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 Solution:123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a, k; double b, n[1010] = &#123; 0 &#125;; for (int i = 0; i &lt; 2; i++) &#123; scanf("%d", &amp;k); while (k--) &#123; scanf("%d%lf", &amp;a, &amp;b); n[a] += b; &#125; &#125; int maxx, cnt = 0; //记录最大的N for (int i = 0; i &lt; 1010; i++) &#123; if (n[i]) &#123; cnt++; maxx = i; &#125; &#125; printf("%d", cnt); for (int i = maxx; i &gt;= 0; i--) if (n[i]) printf(" %d %.1lf", i, n[i]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验六]]></title>
    <url>%2F2019%2F11%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%85%AD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214--以系统管理员身份登录到SQL Server服务器，并使用T-SQL语句实现以下操作：use student--1.将stu数据库中student表的sno定义为主键；alter table studentadd primary key(sno)--2.将数据库stu的表course的cno字段定义为主键，约束名称为cno_pk;alter table courseadd constraint cno_pkprimary key(cno)--3.为表course中的字段cname添加唯一值约束；alter table courseadd constraint cname_uqunique(cname)--4.将数据库stu的表sc的sno及cno字段组合定义为主键，约束名称为sc_pk;alter table scadd constraint sc_pkprimary key(sno,cno)--5.对于数据表sc的sno、cno字段定义为外码，使之与表student的主码sno及表course的主码cno对应，实现如下参照完整性：--1)删除student表中记录的同时删除sc表中与该记录sno字段值相同的记录；--2)修改student表某记录的sno时，若sc表中与该字段值对应的有若干条记录，则拒绝修改；--3)修改course表cno字段值时，该字段在sc表中的对应值也应修改；--4)删除course表一条记录时，若该字段在在sc表中存在，则删除该字段对应的记录；--5)向sc表添加记录时，如果该记录的sno字段的值在student中不存在，则拒绝插入；alter table scadd constraint sc_fk foreign key (sno) references student(sno) on delete cascade on update no action, foreign key (cno) references course(cno) on delete cascade on update cascade--6.定义check约束，要求学生学号sno必须为9位数字字符，且不能以0开头，第二三位皆为0；alter table studentadd constraint sno_ckcheck(sno like '[1-9]00[0-9][0-9][0-9][0-9][0-9][0-9]')--7.定义stu数据库中student表中学生年龄值在16-25范围内；alter table studentadd constraint sage_ckcheck(sage between 16 and 25)--8.定义stu数据库中student表中学生姓名长度在2-8之间；alter table studentadd constraint sname_ckcheck(sname like '__'|'___'|'____'|'_____'|'______'|'_______'|'________')--9.定义stu数据库中student表中学生性别列中只能输入“男”或“女”；alter table studentadd constraint ssex_ckcheck(ssex in ('男','女'))--10.定义stu数据库student表中学生年龄值默认值为20；alter table studentadd constraint sage_dfdefault 20 for sage--11.修改student表学生的年龄值约束可以为15-30范围内；alter table studentdrop constraint sage_ckalter table studentadd constraint sage_ckcheck(sage between 15 and 30)--12.删除上述唯一值约束、外键约束及check约束；alter table coursedrop constraint cname_uqalter table scdrop constraint sc_fkalter table studentdrop constraint sno_ck,sname_ck,ssex_ck,sage_ckuse xsgl--13.设计触发器实现如果一个学生转专业了，那么输出一条信息显示该学生各门课程的平均分。create trigger dept_chon xsfor updateasif update(专业)begin select cj.学号,avg(成绩) from cj,inserted where cj.学号 = inserted.学号 group by cj.学号end update xsset xs.专业 = '信息管理'where xs.学号 = '2006030101'--14.设计触发器实现如果成绩被修改了20分以上，则输出提示信息“修改成绩超过20分，请慎重”。create trigger grade_ck_tgon cjafter updateasbegin declare @pregrade numeric(18,0),@aftgrade numeric(18,0) select @pregrade = 成绩 from inserted select @aftgrade = 成绩 from deleted if((@pregrade-@aftgrade)&gt;20 or (@aftgrade-@pregrade)&gt;20) begin print'修改成绩超过20分，请慎重' endendupdate cjset cj.成绩 = 89where cj.学号 = '2006030101' and cj.课程号 = 'A001'--15.在student表中增加一列total,表示学生选课总门数，初始值为0。alter table xsadd total int default 0--定义一个触发器，实现如下完整性约束：当向SC表插入选课记录时，自动更新student表对应学号的total值,考虑成批插入数据的情况。create trigger sc_inserton cjafter insertasdeclare @total intselect @total = total from xsupdate xsset total = @total+1--16.设计一触发器，约束数据库系统课程的课容量为120。create trigger containon cjfor insert,updateasdeclare @num intselect @num = count(*) from deleted,kc where deleted.课程号 = kc.课程号 and kc.课程名='数据库系统'if @num &gt; 120begin rollback transaction print'数据库课程人数已满'end--17.设有两个表：商品库存表（商品编号，商品名称，库存数量，库存单价，库存金额）；商品销售表（商品编号，商品名称，购货商号，销售数量，销售单价，销售金额）；设计一触发器实现如下业务规则：--（1）保证在商品库存表中插入的数据，库存金额 = 库存数量 * 库存单价。create trigger insert_商品库存表 on 商品库存表 for insert as update 商品库存表 set 库存金额 = 库存数量 * 库存单价 where 商品编号 in (select 商品编号 from inserted)--（2）如果销售的商品不存在库存或者库存为零，则返回提示信息。否则自动减少商品库存表中对应商品的库存数量和库存金额。--建表并验证触发器的执行。create trigger insert_商品销售表 on 商品销售表 for insert as begin transaction if not exists ( select 库存数量 from 商品库存表 where 商品编号 in (select 商品编号 from inserted) ) begin raiseerror('错误！该商品不存在库存，不能销售！',16,1) rollback returnend if exists ( select 库存数量 from 商品库存表 where 商品编号 in (select 商品编号 from inserted) and 库存数量 &lt;= 0 ) begin raiseerror('错误！该商品库存小于等于0，不能销售!',16,1) rollback returnend--18．建立教师表（教工编号，姓名，专业，职称，工资）和工资变化表（教工编号，原工资，新工资）create table teacher(tno char(10) primary key,tname nchar(10),tdept char(16),tpro char(10),tsala money)create table sala_change(tno char(10),tpresala money,taftsala money)--设计触发器实现教授的工资不得低于4000元，如果低于4000元则自动改为4000元。create trigger sala_tgon teacherfor update,insertasdeclare @sala moneyselect @sala = tsala from teacherif @sala &lt; 4000begin update teacher set tsala = 4000 update sala_change set taftsala = 4000,tpresala = @salaend--19.使用第18题的两个表设计触发器实现如果教工的工资发生变化则向工资变化表插入一条记录，包含教工编号，原工资，新工资。create trigger insert_if_changeon teacherfor updateasif update(tsala)begin declare @tno char(10),@tpresala money,@taftsala money select @tno = tno from teacher select @tpresala = tsala from deleted select @taftsala = tsala from inserted insert into sala_change values(@tno,@tpresala,@taftsala)end]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 数据类型]]></title>
    <url>%2F2019%2F11%2F05%2FSQL-Server-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Character 字符串： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 n varchar(n) 可变长度的字符串。最多 8,000 个字符。 varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 text 可变长度的字符串。最多 2GB 字符数据。 Unicode 字符串： 数据类型 描述 存储 nchar(n) 固定长度的 Unicode 数据。最多 4,000 个字符。 nvarchar(n) 可变长度的 Unicode 数据。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 数据。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 数据。最多 2GB 字符数据。 Binary 类型： 数据类型 描述 存储 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制数据。最多 8,000 字节。 varbinary(n) 可变长度的二进制数据。最多 8,000 字节。 varbinary(max) 可变长度的二进制数据。最多 2GB 字节。 image 可变长度的二进制数据。最多 2GB。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许从 -32,768 到 32,767 的所有数字。 2 字节 int 允许从 -2,147,483,648 到 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 和 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 和 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 和 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。 参数 n 指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 bytes datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 bytes smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 bytes date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 bytes datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 bytes timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 其他数据类型： 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验五]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%94%2F</url>
    <content type="text"><![CDATA[问题描述1.二叉树的创建（顺序存储&amp;链式存储）2.进行先序或中序或后序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;using namespace std;//二叉树顺序存储#define MAX_TREE_SIZE 100typedef int TElemType;TElemType Nil = 0;typedef TElemType SqBiTree[MAX_TREE_SIZE];SqBiTree bt;int SqBiTree_Len;void InitSqBiTree(SqBiTree &amp;bt)&#123; for (int i = 0; i &lt; MAX_TREE_SIZE; i++) bt[i] = Nil; printf("二叉树顺序初始化完毕\n"); return;&#125;void CreateSqBiTree(SqBiTree &amp;bt)&#123; printf("请输入结点个数（小于%d）\n", MAX_TREE_SIZE); scanf("%d", &amp;SqBiTree_Len); printf("请输入各结点的值（非零），空结点输入零，两结点之间用空格分开\n"); for (int i = 0; i &lt; SqBiTree_Len; i++) &#123; scanf("%d", &amp;bt[i]); if (i != 0 &amp;&amp; bt[(i + 1) / 2 - 1] == Nil &amp;&amp; bt[i] != Nil) &#123; printf("无双亲的非根节点,顺序存储失败！\n"); return; &#125; &#125; printf("二叉树顺序存储成功\n"); return;&#125;void SqPreOrderTraverse(SqBiTree bt,int i)&#123; if (bt[i - 1] != 0) &#123; printf("%d ", bt[i - 1]); SqPreOrderTraverse(bt, i * 2); SqPreOrderTraverse(bt, i * 2 + 1); &#125; return;&#125;//二叉树链式存储typedef enum PointerTag &#123; Link, Thread &#125;;typedef struct BiThrNode &#123; TElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag, RTag;&#125;BiThrNode, *BiThrTree;void CreateThrBiTree(BiThrTree &amp;T)&#123; char ch; cin &gt;&gt; ch; //scanf("%c", &amp;ch); if (ch == '#') T = NULL; else &#123; T = (BiThrNode*)malloc(sizeof(BiThrNode)); T-&gt;data = ch - '0'; CreateThrBiTree(T-&gt;lchild); CreateThrBiTree(T-&gt;rchild); &#125; return;&#125;void ThrPreOrderTraverse(BiThrNode* T)&#123; if (T != NULL) &#123; printf("%d ", T-&gt;data); ThrPreOrderTraverse(T-&gt;lchild); ThrPreOrderTraverse(T-&gt;rchild); &#125; return;&#125;int main()&#123; InitSqBiTree(bt); CreateSqBiTree(bt); printf("先序遍历顺序二叉树结果为："); SqPreOrderTraverse(bt, 1); printf("\n\n"); BiThrTree T; printf("请输入结点内容，空结点则输入#\n"); CreateThrBiTree(T); printf("先序遍历链式二叉树结果为："); ThrPreOrderTraverse(T); printf("\n"); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行 Python 代码能实现什么丧心病狂的功能？]]></title>
    <url>%2F2019%2F11%2F04%2F%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E4%B8%A7%E5%BF%83%E7%97%85%E7%8B%82%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1.一行代码打印乘法口诀1print('\n'.join([' '.join(["%2s x%2s = %2s"%(j,i,i*j) for j in range(1,i+1)]) for i in range(1,10)])) 2.一行代码打印迷宫1print(''.join(__import__('random').choice('\u2571\u2572') for i in range(50*24))) 3.一行代码（土味）表白1print('\n'.join([''.join([('Love'[(x-y) % len('Love')] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &lt;= 0else' ') for x in range(-30, 30)]) for y in range(30, -30, -1)])) 4.一行代码打印龟龟（/滑稽）1print('\n'.join([''.join(['*' if abs((lambda a:lambda z,c,n:a(a,z,c,n))(lambda s,z,c,n:z if n==0 else s(s,z*z+c,c,n-1))(0,0.02*x+0.05j*y,40))&lt;2 else ' ' for x in range(-80,20)]) for y in range(-20,20)]))]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python十大装B语法]]></title>
    <url>%2F2019%2F11%2F04%2FPython%E5%8D%81%E5%A4%A7%E8%A3%85B%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python 是一种代表简单思想的语言，其语法相对简单，很容易上手。不过，如果就此小视 Python 语法的精妙和深邃，那就大错特错了。本文精心筛选了最能展现 Python 语法之精妙的十个知识点，并附上详细的实例代码。如能在实战中融会贯通、灵活使用，必将使代码更为精炼、高效，同时也会极大提升代码B格，使之看上去更老练，读起来更优雅。1.for-else什么？不是 if 和 else 才是原配吗？No，你可能不知道，else 是个脚踩两只船的家伙，for 和 else 也是一对，而且是合法的。十大装B语法，for-else 绝对算得上南无湾！不信，请看： 12345678910&gt;&gt;&gt; for i in [1,2,3,4]: print(i)else: print(i, '我是else')12344 我是else 如果在 for 和 else 之间（循环体内）有第三者 if 插足，也不会影响 for 和 else 的关系。因为 for 的级别比 if 高，else 又是一个攀附权贵的家伙，根本不在乎是否有 if，以及是否执行了满足 if 条件的语句。else 的眼里只有 for，只要 for 顺利执行完毕，else 就会屁颠儿屁颠儿地跑一遍： 123456789&gt;&gt;&gt; for i in [1,2,3,4]: if i &gt; 2: print(i)else: print(i, '我是else')344 我是else 那么，如何拆散 for 和 else 这对冤家呢？只有当 for 循环被 break 语句中断之后，才会跳过 else 语句： 12345678&gt;&gt;&gt; for i in [1,2,3,4]: if i&gt;2: print(i) breakelse: print(i, '我是else')3 2.一颗星()和两颗星(*)有没有发现，星(*)真是一个神奇的符号！想一想，没有它，C语言还有啥好玩的？同样，因为有它，Python 才会如此的仪态万方、风姿绰约、楚楚动人！Python 函数支持默认参数和可变参数，一颗星表示不限数量的单值参数，两颗星表示不限数量的键值对参数。 我们还是举例说明吧：设计一个函数，返回多个输入数值的和。我们固然可以把这些输入数值做成一个list传给函数，但这个方法，远没有使用一颗星的可变参数来得优雅： 12345678&gt;&gt;&gt; def multi_sum(*args): s = 0 for item in args: s += item return s&gt;&gt;&gt; multi_sum(3,4,5)12 Python 函数允许同时全部或部分使用固定参数、默认参数、单值（一颗星）可变参数、键值对（两颗星）可变参数，使用时必须按照前述顺序书写。 123456789&gt;&gt;&gt; def do_something(name, age, gender='男', *args, **kwds): print('姓名：%s，年龄：%d，性别：%s'%(name, age, gender)) print(args) print(kwds)&gt;&gt;&gt; do_something('xufive', 50, '男', 175, 75, math=99, english=90)姓名：xufive，年龄：50，性别：男(175, 75)&#123;'math': 99, 'english': 90&#125; 3.三元表达式熟悉 C/C++ 的程序员，初上手 python 时，一定会怀念经典的三元操作符，因为想表达同样的思想，用python 写起来似乎更麻烦。比如： 1234567&gt;&gt;&gt; y = 5&gt;&gt;&gt; if y &lt; 0: print('y是一个负数')else: print('y是一个非负数')y是一个非负数 其实，python 是支持三元表达式的，只是稍微怪异了一点，类似于我们山东人讲话。比如，山东人最喜欢用倒装句：打球去吧，要是不下雨的话；下雨，咱就去自习室。翻译成三元表达式就是： 1打球去吧 if 不下雨 else 去自习室 来看看三元表达式具体的使用： 123&gt;&gt;&gt; y = 5&gt;&gt;&gt; print('y是一个负数' if y &lt; 0 else 'y是一个非负数')y是一个非负数 python 的三元表达式也可以用来赋值： 1234&gt;&gt;&gt; y = 5&gt;&gt;&gt; x = -1 if y &lt; 0 else 1&gt;&gt;&gt; x1 4.with-aswith 这个词儿，英文里面不难翻译，但在 Python 语法中怎么翻译，我还真想不出来，大致上是一种上下文管理协议。作为初学者，不用关注 with 的各种方法以及机制如何，只需要了解它的应用场景就可以了。with 语句适合一些事先需要准备，事后需要处理的任务，比如，文件操作，需要先打开文件，操作完成后需要关闭文件。如果不使用with，文件操作通常得这样： 12345fp = open(r"D:\CSDN\Column\temp\mpmap.py", 'r')try: contents = fp.readlines()finally: fp.close() 如果使用 with - as，那就优雅多了： 12&gt;&gt;&gt; with open(r"D:\CSDN\Column\temp\mpmap.py", 'r') as fp: contents = fp.readlines() 5.列表推导式在各种稀奇古怪的语法中，列表推导式的使用频率应该时最高的，对于代码的简化效果也非常明显。比如，求列表各元素的平方，通常应该这样写（当然也有其他写法，比如使用map函数）： 1234567&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; result = list()&gt;&gt;&gt; for i in a: result.append(i*i)&gt;&gt;&gt; result[1, 4, 9, 16, 25] 如果使用列表推导式，看起来就舒服多了： 1234&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; result = [i*i for i in a]&gt;&gt;&gt; result[1, 4, 9, 16, 25] 事实上，推导式不仅支持列表，也支持字典、集合、元组等对象。有一篇博文《一行 Python 代码能实现什么丧心病狂的功能？》，里面的例子，都是列表推导式实现的。 6.列表索引的各种骚操作Python 引入负整数作为数组的索引，这绝对是喜大普奔之举。想想看，在C/C++中，想要数组最后一个元素，得先取得数组长度，减一之后做索引，严重影响了思维的连贯性。Python语言之所以获得成功，我个人觉得，在诸多因素里面，列表操作的便捷性是不容忽视的一点。请看： 123456789101112131415161718192021&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; a[2:4][2, 3]&gt;&gt;&gt; a[3:][3, 4, 5]&gt;&gt;&gt; a[1:][1, 2, 3, 4, 5]&gt;&gt;&gt; a[:][0, 1, 2, 3, 4, 5]&gt;&gt;&gt; a[::2][0, 2, 4]&gt;&gt;&gt; a[1::2][1, 3, 5]&gt;&gt;&gt; a[-1]5&gt;&gt;&gt; a[-2]4&gt;&gt;&gt; a[1:-1][1, 2, 3, 4]&gt;&gt;&gt; a[::-1][5, 4, 3, 2, 1, 0] 如果说，这些你都很熟悉，也经常用，那么接下来这个用法，你一定会感觉很神奇： 12345678&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; b = ['a', 'b']&gt;&gt;&gt; a[2:2] = b&gt;&gt;&gt; a[0, 1, 'a', 'b', 2, 3, 4, 5]&gt;&gt;&gt; a[3:6] = b&gt;&gt;&gt; a[0, 1, 'a', 'a', 'b', 4, 5] 7.lambda函数lambda 听起来很高大上，其实就是匿名函数（了解js的同学一定很熟悉匿名函数）。匿名函数的应用场景是什么呢？就是仅在定义匿名函数的地方使用这个函数，其他地方用不到，所以就不需要给它取个阿猫阿狗之类的名字了。下面是一个求和的匿名函数，输入参数有两个，x和y，函数体就是x+y，省略了return关键字。 123&gt;&gt;&gt; lambda x,y: x+y&lt;function &lt;lambda&gt; at 0x000001B2DE5BD598&gt;&gt;&gt;&gt; (lambda x,y: x+y)(3,4) # 因为匿名函数没有名字，使用的时候要用括号把它包起来 匿名函数一般不会单独使用，而是配合其他方法，为其他方法提供内置的算法或判断条件。比如，使用排序函数sorted对多维数组或者字典排序时，就可以指定排序规则。 12345&gt;&gt;&gt; a = [&#123;'name':'B', 'age':50&#125;, &#123;'name':'A', 'age':30&#125;, &#123;'name':'C', 'age':40&#125;]&gt;&gt;&gt; sorted(a, key=lambda x:x['name']) # 按姓名排序[&#123;'name': 'A', 'age': 30&#125;, &#123;'name': 'B', 'age': 50&#125;, &#123;'name': 'C', 'age': 40&#125;]&gt;&gt;&gt; sorted(a, key=lambda x:x['age']) # 按年龄排序[&#123;'name': 'A', 'age': 30&#125;, &#123;'name': 'C', 'age': 40&#125;, &#123;'name': 'B', 'age': 50&#125;] 再举一个数组元素求平方的例子，这次用map函数： 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; for item in map(lambda x:x*x, a): print(item, end=', ')1, 4, 9, 8.yield以及生成器和迭代器要理解 yield，得先了解 generator（生成器）。要了解generator，得先知道 iterator（迭代器）。哈哈哈，绕晕了吧？算了，我还是说白话吧。 话说py2时代，range()返回的是list，但如果range(10000000)的话，会消耗大量内存资源，所以，py2又搞了一个xrange()来解决这个问题。py3则只保留了xrange()，但写作range()。xrange()返回的就是一个迭代器，它可以像list那样被遍历，但又不占用多少内存。generator（生成器）是一种特殊的迭代器，只能被遍历一次，遍历结束，就自动消失了。总之，不管是迭代器还是生成器，都是为了避免使用list，从而节省内存。那么，如何得到迭代器和生成器呢？ python内置了迭代函数 iter，用于生成迭代器，用法如下： 12345678&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a_iter = iter(a)&gt;&gt;&gt; a_iter&lt;list_iterator object at 0x000001B2DE434BA8&gt;&gt;&gt;&gt; for i in a_iter: print(i, end=', ')1, 2, 3, yield 则是用于构造生成器的。比如，我们要写一个函数，返回从0到某正整数的所有整数的平方，传统的代码写法是这样的： 12345678&gt;&gt;&gt; def get_square(n): result = list() for i in range(n): result.append(pow(i,2)) return result&gt;&gt;&gt; print(get_square(5))[0, 1, 4, 9, 16] 但是如果计算1亿以内的所有整数的平方，这个函数的内存开销会非常大，这是 yield 就可以大显身手了： 1234567891011&gt;&gt;&gt; def get_square(n): for i in range(n): yield(pow(i,2))&gt;&gt;&gt; a = get_square(5)&gt;&gt;&gt; a&lt;generator object get_square at 0x000001B2DE5CACF0&gt;&gt;&gt;&gt; for i in a: print(i, end=', ')0, 1, 4, 9, 16, 如果再次遍历，则不会有输出了。 9.装饰器刚弄明白迭代器和生成器，这又来个装饰器，Python 咋这么多器呢？的确，Python 为我们提供了很多的武器，装饰器就是最有力的武器之一。装饰器很强大，我在这里尝试从需求的角度，用一个简单的例子，说明装饰器的使用方法和制造工艺。 假如我们需要定义很多个函数，在每个函数运行的时候要显示这个函数的运行时长，解决方案有很多。比如，可以在调用每个函数之前读一下时间戳，每个函数运行结束后再读一下时间戳，求差即可；也可以在每个函数体内的开始和结束位置上读时间戳，最后求差。不过，这两个方法，都没有使用装饰器那么简单、优雅。下面的例子，很好地展示了这一点。 1234567891011121314151617181920&gt;&gt;&gt; import time&gt;&gt;&gt; def timer(func): def wrapper(*args,**kwds): t0 = time.time() func(*args,**kwds) t1 = time.time() print('耗时%0.3f'%(t1-t0,)) return wrapper&gt;&gt;&gt; @timerdef do_something(delay): print('函数do_something开始') time.sleep(delay) print('函数do_something结束')&gt;&gt;&gt; do_something(3)函数do_something开始函数do_something结束耗时3.077 timer() 是我们定义的装饰器函数，使用@把它附加在任何一个函数（比如do_something）定义之前，就等于把新定义的函数，当成了装饰器函数的输入参数。运行 do_something() 函数，可以理解为执行了timer(do_something) 。细节虽然复杂，不过这么理解不会偏差太大，且更易于把握装饰器的制造和使用。 10.巧用断言assert所谓断言，就是声明表达式的布尔值必须为真的判定，否则将触发 AssertionError 异常。严格来讲，assert是调试手段，不宜使用在生产环境中，但这不影响我们用断言来实现一些特定功能，比如，输入参数的格式、类型验证等。 1234567891011121314151617181920&gt;&gt;&gt; def i_want_to_sleep(delay): assert(isinstance(delay, (int,float))), '函数参数必须为整数或浮点数' print('开始睡觉') time.sleep(delay) print('睡醒了')&gt;&gt;&gt; i_want_to_sleep(1.1)开始睡觉睡醒了&gt;&gt;&gt; i_want_to_sleep(2)开始睡觉睡醒了&gt;&gt;&gt; i_want_to_sleep('2')Traceback (most recent call last): File "&lt;pyshell#247&gt;", line 1, in &lt;module&gt; i_want_to_sleep('2') File "&lt;pyshell#244&gt;", line 2, in i_want_to_sleep assert(isinstance(delay, (int,float))), '函数参数必须为整数或浮点数'AssertionError: 函数参数必须为整数或浮点数]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验五]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%94%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879--1．创建一windows用户（名字自定），用sql语句建立windows验证模式的登录名。默认数据库为student--2．用sql语句和系统存储过程建立登录名sqluser,密码为1234 --sqlcreate login sqluser with password='1234',default_database=student--存储过程exec sp_addlogin 'sqluser','1234'--3．为student数据库新建用户u1，其登录名为sqluser。create user u1 from login sqluser--4．新建登录usersf，并将其加入到sysadmin固定服务器角色中。exec sp_addsrvrolemember 'usersf','sysadmin'--5．将student用户usersf（登录名为usersf）加入到db_owner角色中，使其全权负责该数据库,并验证其权限。exec sp_addsrvrolemember 'db_owner','usersf'--6．为SPJ数据库新建用户u2，u3，其登录名分别为u2，u3。create login u2 with password='',default_database=SPJcreate user u2 for login u2create login u3 with password='',default_database=SPJcreate user u3 for login u3--（1）授予用户u2对S表有SELECT 权，对P表颜色（COLOR）具有更新权限；grant selecton Sto u2grant update(color)on Pto u2--（2）u2将其拥有的权限授予u3；grant u2to u3--（3）用sql语句逐一验证u2、u3所获得的权限。select * from Supdate Pset color='红'--（4）撤销用户u3所获得的权限，并验证。revoke selecton table Sfrom u3revoke update(color)on table Pfrom u3--7.在student数据库中建立角色operate,该角色具有对student和course表的查询权限；具有对表sc的插入和修改权限。create role operategrant selecton studentto operategrant selecton courseto operategrant update,inserton scto operate--8.拒绝用户u1对sc表的修改权限。deny update on scto u1 cascade--9.使用存储过程将角色operate赋给用户u1,并用sql语句验证其权限。（特别验证u1对sc表的修改权限）exec sp_addrolemember 'operate','u1'select *from studentselect *from courseupdate scset grade = 100where sno = '200515001' and cno = '1']]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1020 导弹拦截]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%B4%9B%E8%B0%B7-P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式1行，若干个整数（个数≤100000） 输出格式2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 #1 1389 207 155 300 299 170 158 65 输出 #1 1262 说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分 每点两问，按问给分 题解12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[100010], d1[100010], d2[100010], n;inline bool read(int &amp;x) &#123; char c = getchar(); if (c == EOF) return false; while (c &gt; '9' || c &lt; '0') c = getchar(); while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); &#125; return true;&#125;int main() &#123; //freopen("1.txt", "r", stdin); //freopen("2.txt", "w", stdout); while (read(a[++n])); n--; int len1 = 1, len2 = 1; d1[1] = d2[1] = a[1]; for (int i = 2; i &lt;= n; i++) &#123; if (d1[len1] &gt;= a[i]) d1[++len1] = a[i]; else *upper_bound(d1 + 1, d1 + 1 + len1, a[i], greater&lt;int&gt;()) = a[i]; if (d2[len2] &lt; a[i]) d2[++len2] = a[i]; else *lower_bound(d2 + 1, d2 + 1 + len2, a[i]) = a[i]; &#125; printf("%d\n%d", len1, len2); //fclose(stdin); //fclose(stdout) return 0;&#125;]]></content>
      <categories>
        <category>LuoGu</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1001 A+B Format]]></title>
    <url>%2F2019%2F10%2F28%2FPTA-Advanced-Level-1001-A-B-Format%2F</url>
    <content type="text"><![CDATA[Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6 ≤a,b≤10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 Solution:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt; using namespace std; int main()&#123; int a, b, c, ans[10], flag = 0, n = 1; scanf("%d%d", &amp;a, &amp;b); c = a + b; if (c == 0) &#123; //第一次提交没有想到a+b为0这一点 printf("0"); return 0; &#125; if (c &gt; 0) //determine the positive and negative flag = 1; c = abs(c); while (c) &#123; //convert the sum into an array ans[n++] = c % 10; c /= 10; &#125; if (flag == 0) printf("-"); for (int i = n - 1; i &gt; 0; i--) &#123; if (i % 3 == 0 &amp;&amp; i != n - 1) printf(","); printf("%d", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验四]]></title>
    <url>%2F2019%2F10%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229--一、对xsgl数据库完成下列操作要求：use xsgl--1.将被全部学生都选修了的课程的总学分改为4学分update kc set kc.学分 = 4where kc.课程号 in (select kc.课程号 from kc where not exists (select * from xs where not exists (select * from cj where cj.课程号 = kc.课程号 and cj.学号 = xs.学号)))--2.从学生表删除没有选课的学生delete from xswhere xs.学号 not in (select cj.学号 from cj)--3.将每个学生的平均分，总分和选课门数插入到数据库中（学号，姓名，平均分，总分，选课门数）create table new(学号 char(10),姓名 nchar(10),平均分 numeric(10,2),总分 numeric(10,2),选课门数 smallint)insert into newselect xs.学号,xs.姓名,avg(cj.成绩),sum(cj.成绩),count(cj.课程号)from xs left join cj on xs.学号=cj.学号group by xs.学号,xs.姓名--4.创建每门课程的平均分和选课人数的视图（课程号，课程名，平均分，人数）create view Course(课程号,课程名,平均分,人数)asselect kc.课程号,kc.课程名,avg(cj.成绩) 平均分,count(cj.学号) 人数from kc left join cj on (kc.课程号 = cj.课程号)group by kc.课程号,kc.课程名--5.将李强同学从学生表删除（提示应该先删除李强同学的选课记录）delete from cjwhere cj.学号 = (select xs.学号 from xs where xs.姓名 = '李强')delete from xswhere xs.姓名 = '李强'--6.插入一条选课记录（具体内容自己选）insertinto xsvalues('2018008003','彭于晏','男',null,null,null,null,null)insertinto cjvalues('2018008003','A001',null)--7.创建网络工程专业的学生的选课信息的视图，要求视图包含，学号，姓名，专业，课程号，课程名，成绩create view IT(学号,姓名,专业,课程号,课程名,成绩)asselect xs.学号,xs.姓名,xs.专业,kc.课程号,kc.课程名,cj.成绩from xs left join cj on xs.学号 = cj.学号 right join kc on cj.课程号 = kc.课程号where xs.专业 = '网络工程'--8.查询网络工程专业的各科的平均成绩，要求使用第7题创建的视图进行查询select IT.课程号,avg(IT.成绩) 平均成绩from ITgroup by IT.课程号--9.查询被信息管理专业的学生都选修了的课程的课程号，课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from xs where xs.专业 = '信息管理' and not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--10.显示选修课程数最多的学号及选修课程数最少的学号，姓名（使用派生表实现）select xs.学号,xs.姓名,count(*) 门数from xs,cj,(select top 1 count(*) from cj group by cj.学号 order by count(*) desc) Maxx(门数), (select top 1 count(*) from cj group by cj.学号 order by count(*)) Minn(门数)where cj.学号 = xs.学号group by xs.学号,xs.姓名,Maxx.门数,Minn.门数having count(*) = Maxx.门数 or count(*) = Minn.门数--11.查询每个学生成绩高于自己的平均成绩的学号，姓名，课程号和成绩（使用派生表实现）select xs.学号,xs.姓名,cj.课程号,cj.成绩from xs,cj,(select cj1.学号,avg(cj1.成绩) 平均成绩 from cj cj1 group by cj1.学号) avg_gradewhere cj.学号 = avg_grade.学号 and xs.学号 = cj.学号 and cj.成绩 &gt; avg_grade.平均成绩--12.自己验证with check option的作用create view IEasselect xs.学号,xs.姓名,xs.性别,xs.专业from xswhere xs.专业 = '网络工程'with check optioninsert into IE(学号,姓名)values('2018008002','吴彦祖') --13.创建一个网络工程系的学生基本信息的视图MA_STUDENT，在此视图的基础上，再定义一个该专业女生信息的视图，然后再删除MA_STUDENT，观察执行情况。create view MA_STUDENTasselect *from xswhere xs.专业 = '网络工程'with check optioncreate view Femaleasselect *from MA_STUDENTwhere MA_STUDENT.性别 = '女'drop view MA_STUDENT--14.查询和程明同龄的学生的学号和姓名以及年龄select xs.学号,xs.姓名,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) = (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.姓名 = '程明')--15.查询没有被全部的学生都选修的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere exists (select * from xs where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--16.查询选课学生包含了选英语的全部学生的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from cj where cj.课程号 = (select kc.课程号 from kc where kc.课程名 = '英语') and not exists (select * from cj c where c.学号 = cj.学号 and c.课程号 = kc.课程号))--二、使用Northwind数据库完成下列操作use Northwind--1. 将员工lastname是: Peacock处理的订单中购买数量超过50的商品折扣改为七折update [Order Details]set Discount = 0.3where [Order Details].Quantity &gt; 50 and [Order Details].OrderID in (select O1.OrderID from [Order Details] O1,Employees,Orders where Employees.EmployeeID = Orders.EmployeeID and Orders.OrderID = O1.OrderID and Employees.LastName = 'Peacock' and O1.Quantity &gt; 50)--2. 删除lastname是: Peacock处理的所有订单deletefrom [Order Details]where [Order Details].OrderID in (select distinct O1.OrderID from [Order Details] O1,Employees,Orders where O1.OrderID = Orders.OrderID and Orders.EmployeeID = Employees.EmployeeID and Employees.LastName = 'Peacock')deletefrom Orderswhere Orders.EmployeeID = (select Employees.EmployeeID from Employees where Employees.LastName = 'Peacock')--3. 将每个订单的订单编号，顾客编号，产品总数量，总金额插入到数据库中create table OrderInfo(订单编号 int,顾客编号 nchar(5),产品总数量 smallint,总金额 money)insertinto OrderInfoselect Orders.OrderID,Orders.CustomerID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1- [Order Details].Discount)) 金额from [Order Details],Orderswhere [Order Details].OrderID = Orders.OrderIDgroup by Orders.OrderID,Orders.CustomerID--4. 插入一个新的订单，要求该订单购买了商品编号为5,7,9的商品。（5号商品买了10个，7号买了20个，9号买了15个，都没有折扣）insert into [Order Details]values('10325','5', '50', '10', '0')insert into [Order Details]values('10325','7', '70', '20', '0')insert into [Order Details]values('10325','9', '90', '15', '0')--5. 将每年每个员工处理订单的数量和订单的总金额创建为视图create view Employasselect Employees.EmployeeID,datename(yy,Orders.OrderDate) 年份, count(distinct Orders.OrderID) 订单数量,sum([Order Details].Quantity) 数量, sum([Order Details].Quantity*[Order Details].UnitPrice*(1-[Order Details].Discount)) 订单总金额from Employees left join Orders on Employees.EmployeeID=Orders.EmployeeID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Employees.EmployeeID,datename(yy,Orders.OrderDate)--6. 购买了CustomerID是‘VINET’用户所购买的全部商品的用户的CustomerID和CompanyName。select distinct Customers.CustomerID,Customers.CompanyNamefrom Customers,Orders where Customers.CustomerID = Orders.CustomerID and not exists (select * from Orders o2,Customers c2 where o2.CustomerID = c2.CustomerID and o2.CustomerID = 'VINET' and not exists (select * from Orders o3 where o3.CustomerID = Orders.CustomerID))]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验三]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337--一.对xsgl数据库完成以下操作--1.查询没有选修英语的学生的学号，姓名和课程号，课程名，成绩select xs.学号,xs.姓名,kc.课程号,kc.课程名,cj.成绩from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号 and kc.课程名 &lt;&gt; '英语'--2.查询英语成绩高于英语的平均成绩的学生的学号，姓名，成绩select xs.学号,xs.姓名,cj.成绩from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.成绩 &gt; (select avg(cj.成绩) from kc,cj where cj.课程号 = kc.课程号 and kc.课程名 = '英语')--3.查询选修了英语和高数(数学)的学生的学号和姓名（要求使用两种方法实现）select xs.学号,xs.姓名from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.学号 in (select cj.学号 from cj,xs,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '数学')select xs.学号,xs.姓名from xs,cj,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and 课程名 = '英语' and xs.学号 in (select 学号 from cj where 课程号 = (select 课程号 from kc where 课程名 = '数学'))--4.查询没有选修程明所选修的全部课程的学生的姓名select xs.姓名from xs,cjwhere xs.学号 = cj.学号 and cj.课程号 not in (select cj.课程号 from xs,cj where xs.学号 = cj.学号 and xs.姓名 = '程明')--5.查询每个专业年龄超过该专业平均年龄的学生的姓名和专业select xs1.姓名,xs1.专业from xs xs1where datediff(yy,xs1.出生时间,getdate()) &gt; (select avg(datediff(yy,xs2.出生时间,getdate())) from xs xs2 where xs1.专业 = xs2.专业)--6.查询每个专业每门课程的专业，课程号，课程名，选课人数，平均分和最高分select xs.专业,kc.课程号,kc.课程名,count(*) 选课人数,avg(cj.成绩) 平均分,max(cj.成绩) 最高分from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号group by kc.课程号,kc.课程名,xs.专业--7.查询每个学生取得最高分的课程的课程号，课程名和成绩select cj.学号,kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.成绩 &gt;= all (select cj2.成绩 from cj cj2 where cj2.学号 = cj.学号)--8.查询每个专业年龄最高的学生的学号，姓名，专业和年龄select xs.学号,xs.姓名,xs.专业,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) &gt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = xs.专业)--9.查询没有选修数据结构和操作系统的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.学号 not in (select cj.学号 from cj where cj.课程号 in (select kc.课程号 from kc where kc.课程名 = '数据结构' or kc.课程名 = '操作系统'))--10.查询网络工程专业年龄最小的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.专业 = '网络工程' and datediff(yy,xs.出生时间,getdate()) &lt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = '网络工程')--11.查询选课人数超过5人的课程的课程号，课程名和成绩select kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.课程号 in (select cj2.课程号 from cj cj2 group by cj2.课程号 having count(cj2.学号) &gt; 5)--12.查询选修了全部课程的学生的学号和姓名（用两种方法实现）select xs.学号,xs.姓名from xswhere not exists (select * from kc where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))select xs.学号,xs.姓名from xswhere xs.学号 in (select cj.学号 from cj group by cj.学号 having count(*) = (select count(*) from kc))--13.查询选课人数最多的课程号和课程名（包含并列）select cj.课程号,kc.课程名from kc,cjwhere kc.课程号 = cj.课程号group by cj.课程号,kc.课程名having count(*) &gt;= all (select count(*) from cj cj2 group by cj2.课程号)--14.查询选修了程明所选修的全部课程的学生的姓名select distinct xs.姓名from xs,cj where xs.学号 = cj.学号 and not exists (select * from cj cj2,xs xs2 where xs2.学号 = cj2.学号 and xs2.姓名 = '程明' and not exists (select * from cj cj3 where cj3.学号 = cj.学号 and cj 3.课程号 = cj2.课程号))--二．对罗斯文数据库完成一下查询--15.查询每个订单购买产品的数量和总金额，显示订单号，数量，总金额select [Order Details].OrderID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details]group by [Order Details].OrderID--16.查询每个员工在7月份处理订单的数量select count(Orders.OrderID) 订单数量from Orders right join Employees on (Employees.EmployeeID = Orders.EmployeeID)where month(Orders.OrderDate) = '07'group by Employees.EmployeeID--17.查询每个顾客的订单总数，显示顾客ID，订单总数select Customers.CustomerID,count(Orders.OrderID) 订单总数from Orders right join Customers on (Customers.CustomerID = Orders.CustomerID)group by Customers.CustomerID--18.查询每个顾客的订单总数和订单总金额select Customers.CustomerID,count(distinct Orders.OrderID) 订单总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from Orders right join Customers on Orders.CustomerID=Customers.CustomerID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Customers.CustomerID--19.查询每种产品的卖出总数和总金额select sum([Order Details].Quantity) 卖出总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details] right join Products on ([Order Details].ProductID = Products.ProductID)group by Products.ProductID--20.查询购买过全部商品的顾客的ID和姓名select Customers.CustomerID,Customers.ContactNamefrom Customerswhere not exists (select * from Products where not exists (select * from Orders,[Order Details] where Orders.OrderID = [Order Details].OrderID and Products.ProductID = [Order Details].ProductID and Customers.CustomerID = Orders.CustomerID))--三.对books数据库完成以下操作--21.查询各种类别的图书的类别和数量（包含目前没有图书的类别）select BookType.TypeName,count(BookInfo.TypeID) 数量from BookType left join BookInfo on (BookType.TypeID = BookInfo.TypeID)group by BookType.TypeName--22.查询借阅了‘数据库基础’的读者的卡编号和姓名select BorrowInfo.CardNo,CardInfo.Readerfrom BorrowInfo,CardInfo,BookInfowhere BorrowInfo.BookNo = BookInfo.BookNo and BorrowInfo.CardNo = CardInfo.CardNo and BookInfo.BookName = '数据库基础'--23.查询各个出版社的图书价格超过这个出版社图书的平均价格的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.Price &gt; (select avg(b1.Price) from BookInfo b1 where BookInfo.Publisher = b1.Publisher)--24.查询没有借过图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere CardInfo.CardNo not in (select BorrowInfo.CardNo from BorrowInfo)--25.查询借阅次数超过2次的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfo,BorrowInfowhere CardInfo.CardNo = BorrowInfo.CardNogroup by CardInfo.CardNo,CardInfo.Readerhaving count(BorrowInfo.CardNo) &gt; 2--26.查询借阅卡的类型为老师和研究生的读者人数select count(CardInfo.CardNo) 读者人数from CardType,CardInfowhere CardInfo.CTypeID = CardType.CTypeID and (CardType.TypeName = '教师' or CardType.TypeName = '研究生')--27.查询没有被借过的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.BookNo not in (select BorrowInfo.BookNo from BorrowInfo)--28.查询没有借阅过英语类型的图书的学生的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo,BorrowInfo,BookType,CardType where BookType.TypeName='英语' and CardType.TypeName = '学生' and CardType.CTypeID = CardInfo.CTypeID and BookType.TypeID=BookInfo.TypeID and BookInfo.BookNo=BorrowInfo.BookNo and BorrowInfo.CardNo=CardInfo.CardNo)--29.查询借阅了‘计算机应用’类别的‘数据库基础’课程的学生的编号读者以及该读者的借阅卡的类型select CardInfo.CardNo,CardType.TypeNamefrom CardInfo,CardType,BorrowInfowhere CardInfo.CTypeID = CardType.CTypeID and BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo in (select BookInfo.BookNo from BookInfo where BookInfo.BookName = '数据库基础')--30.查询借阅过了全部图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo where not exists (select * from BorrowInfo where BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo = BookInfo.BookNo))--四．对商场数据库完成以下操作--Market (mno, mname, city)--Item (ino, iname, type, color)--Sales (mno, ino, price)--其中，market表示商场，它的属性依次为商场号、商场名和所在城市；item表示商品，它的属性依次为商品号、商品名、商品类别和颜色；sales表示销售，它的属性依次为商场号、商品号和售价。用SQL语句实现下面的查询要求：--1.列出北京各个商场都销售，且售价均超过10000 元的商品的商品号和商品名select item.ino,item.inamefrom itemwhere not exists (select * from sales,market where sales.mno = market.mno and market.city = '北京' and not exists (select * from sales s1 where s1.ino = item.ino and s1.mno = sales.mno and s1.price &gt; 10000))--2.列出在不同商场中最高售价和最低售价只差超过100 元的商品的商品号、最高售价和最低售价select sales.ino,max(sales.price) 最高售价,min(sales.price) 最低售价from salesgroup by sales.inohaving max(sales.price) - min(sales.price) &gt; 100--3.列出售价超过该商品的平均售价的各个商品的商品号和售价select sales.ino,sales.pricefrom saleswhere sales.price &gt; (select avg(s2.price) from sales s2 where s2.ino = sales.ino)--4.查询每个每个城市各个商场售价最高的商品的商场名，城市，商品号和商品名select market.mname,market.city,sales.ino,item.inamefrom market,sales,itemwhere market.mno = sales.mno and item.ino = sales.ino and sales.price &gt;= all (select s2.price from sales s2 where s2.mno = sales.mno)--5.查询销售商品数量最多的商场的商场号，商场名和城市select market.mno,market.mname,market.cityfrom market,saleswhere market.mno = sales.mnogroup by market.mno,market.mname,market.cityhaving count(sales.ino) &gt;= all (select count(s2.ino) from sales s2 group by s2.mno)--6.查询销售了冰箱和洗衣机的商场号，商场名和城市select distinct market.mno,market.mname,market.cityfrom market,saleswhere market.mno in (select s1.mno from sales s1 where s1.ino in (select item.ino from item where item.iname = '冰箱') and s1.mno in (select s2.mno from sales s2 where s2.ino in (select item.ino from item where item.iname = '洗衣机')))--7.查询所有商场都销售了的商品的商品号和商品名。（用两种方法实现）select item.ino,item.inamefrom itemwhere not exists (select * from market where not exists (select * from sales where sales.mno = market.mno and sales.ino = item.ino))select item.ino,item.inamefrom item,saleswhere item.ino = sales.inogroup by sales.ino, item.ino,item.inamehaving count(sales.mno) = (select count(market.mno) from market)]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验二]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !=''--2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001'--3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%'--4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc--5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号--6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35--7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001')--8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs--9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs--10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%'--12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20--13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80--14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业--15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1)--16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5--17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号--19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别--20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业--21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/--22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%'--23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号)select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号)--24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002')--25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1)--二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1'--2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno--3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200--4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红')--5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400--6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验四]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[问题描述对一个稀疏矩阵进行转置要求用十字链表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct OLNode&#123; int i, j; ElemType e; struct OLNode *right, *down;&#125;OLNode, *OLink;typedef struct CrossList&#123; OLink *rhead, *chead; int mu, nu, tu;&#125;CrossList, *pCrossList;void CreateSMatrix_OL(pCrossList M)&#123; //输入行数列数以及非零元个数 printf("请输入行数，列数，非零元素个数：\n"); scanf("%d%d%d", &amp;M-&gt;mu, &amp;M-&gt;nu, &amp;M-&gt;tu); if (M-&gt;tu * 20 &gt; M-&gt;mu * M-&gt;nu) printf("非稀疏矩阵，不建议使用此方法！\n"); //动态申请行和列指针数组 M-&gt;rhead = (OLink *)malloc(sizeof(OLink)*M-&gt;mu); if (M-&gt;rhead == NULL) return; M-&gt;chead = (OLink *)malloc(sizeof(OLink)*M-&gt;nu); if (M-&gt;chead == NULL)&#123; free(M-&gt;rhead); return; &#125; //初始化两个数组 int i, j; for (i = 1; i &lt;= M-&gt;mu; i++) M-&gt;rhead[i] = NULL; for (j = 1; j &lt;= M-&gt;nu; j++) M-&gt;chead[j] = NULL; //创建节点并连接到十字链表上 for (i = 1; i &lt;= M-&gt;tu; i++)&#123; OLink p = (OLink)malloc(sizeof(OLNode)); if (p == NULL) return; printf("请输入非零元素的行，列，值\n"); scanf("%d%d%d", &amp;p-&gt;i, &amp;p-&gt;j, &amp;p-&gt;e); p-&gt;down = NULL; p-&gt;right = NULL; //连接行 //如果该行并没有连接任何节点（NULL）或者该行连接的第一个节点的列值大于当前待连接的节点则直接将当前节点连接到该行第一个节点的位置 if (M-&gt;rhead[p-&gt;i] == NULL || M-&gt;rhead[p-&gt;i]-&gt;j &gt; p-&gt;j)&#123; p-&gt;right = M-&gt;rhead[p-&gt;i]; M-&gt;rhead[p-&gt;i] = p; &#125; //否则遍历该行找到合适的位置插入 else &#123; OLink q = M-&gt;rhead[p-&gt;i];//指向第一个节点，从第一个节点开始遍历 while (q-&gt;right != NULL &amp;&amp; q-&gt;right-&gt;j &lt; p-&gt;j)//遍历到前一个节点 q = q-&gt;right; p-&gt;right = q-&gt;right; q-&gt;right = p; &#125; //连接列 if (M-&gt;chead[p-&gt;j] == NULL || M-&gt;chead[p-&gt;j]-&gt;i &gt; p-&gt;i) &#123; p-&gt;down = M-&gt;chead[p-&gt;j]; M-&gt;chead[p-&gt;j] = p; &#125; else &#123; OLink pNodeTravel = M-&gt;chead[p-&gt;j]; while (pNodeTravel-&gt;down != NULL &amp;&amp; pNodeTravel-&gt;down-&gt;i &lt; p-&gt;i) pNodeTravel = pNodeTravel-&gt;down; p-&gt;down = pNodeTravel-&gt;down; pNodeTravel-&gt;down = p; &#125; &#125;&#125;void TransSMatrix_OL(CrossList M, CrossList *T)&#123; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; //Q的头节点的初始化 if (!(T-&gt;rhead = (OLink *)malloc((T-&gt;mu + 1) * sizeof(OLink)))) &#123;printf("内存空间申请失败！");return;&#125; if (!(T-&gt;chead = (OLink *)malloc((T-&gt;nu + 1) * sizeof(OLink)))) &#123; printf("内存空间申请失败！"); return; &#125; for (int i = 1; i &lt;= T-&gt;mu; i++) T-&gt;rhead[i] = NULL; for (int i = 1; i &lt;= T-&gt;nu; i++) T-&gt;chead[i] = NULL; if (!M.tu) return; OLink p, q, q_row, q_col; for (int i = 1; i &lt;= M.nu; i++)&#123; if (M.chead[i]) &#123; for (q = M.chead[i]; q;) &#123; if (!(p = (OLink)malloc(sizeof(OLNode))))&#123; printf("内存空间申请失败！"); return; &#125; p-&gt;i = q-&gt;j; p-&gt;j = q-&gt;i; p-&gt;e = q-&gt;e; p-&gt;right = p-&gt;down = NULL; q_row = T-&gt;rhead[i]; if (NULL == T-&gt;rhead[i]) T-&gt;rhead[i] = p; else &#123; while (q_row-&gt;right) q_row = q_row-&gt;right; q_row-&gt;right = p; &#125; q_col = T-&gt;chead[p-&gt;j]; if (T-&gt;chead[p-&gt;j] == NULL) T-&gt;chead[p-&gt;j] = p; else &#123; while (q_col-&gt;down) q_col = q_col-&gt;down; q_col-&gt;down = p; &#125; q = q-&gt;down; &#125; &#125; &#125; return;&#125;void OutputSMatrix_OL(pCrossList M, char s[])&#123; int i, j; OLink p; printf("----------------------\n"); printf("%s矩阵为：\n", s); for (i = 1; i &lt;= M-&gt;mu; i++)&#123; p = M-&gt;rhead[i]; for (j = 1; j &lt;= M-&gt;nu; j++)&#123; if (p != NULL &amp;&amp; p-&gt;j == j) &#123; printf("%d ", p-&gt;e); p = p-&gt;right; &#125; else printf("0 "); &#125; printf("\n"); &#125; printf("----------------------\n"); printf("\n"); return;&#125;int main()&#123; CrossList M, T; CreateSMatrix_OL(&amp;M); char s1[] = "原始"; OutputSMatrix_OL(&amp;M, s1); TransSMatrix_OL(M, &amp;T); char s2[] = "转置后"; OutputSMatrix_OL(&amp;T, s2); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验三]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[问题描述对一个对称矩阵进行压缩及解压缩注意 压缩时： 第一步：完整地显示矩阵 第二步： 完整地显示一维数组 ——————————————————————————————————————— 解压缩时： 第一步：完整地显示一维数组 第二步：完整地显示矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define Matrix_Num 5void input_Matrix(int *Matrix)&#123; printf("输入方阵：\n"); for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; scanf("%d", &amp;Matrix[Matrix_Num * i + j]); &#125; &#125; printf("\n"); return;&#125;void show1D(int Compressed[])&#123; for (int i = 0; i &lt; Matrix_Num*(Matrix_Num + 1) / 2; i++) printf("%d ", Compressed[i]); printf("\n"); return;&#125;void show2D(int Matrix[])&#123; for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; printf("%d ", Matrix[Matrix_Num*i + j]); &#125; printf("\n"); &#125; return;&#125;void compress(int Matrix[],int *Compressed)&#123; int n = 0; printf("您输入的方阵为：\n"); show2D(Matrix); printf("压缩后\n"); for (int i = 0; i &lt; Matrix_Num; i++) for (int j = 0; j &lt;= i; j++) Compressed[n++] = Matrix[Matrix_Num*i + j]; show1D(Compressed); printf("\n"); return;&#125;void uncompress_O1(int Compressed[],int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; int i, j; i = ceil(sqrt(2.25 + 2 * k) - 0.5); j = k - i * (i - 1) / 2; i--; Uncompressed[Matrix_Num*i + j] = Compressed[k]; Uncompressed[Matrix_Num*j + i] = Compressed[k]; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; int j = k - i * (i - 1) / 2 + 1; if (i &gt;= j &amp;&amp; j &gt;= 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; break; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On2(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (k == i * (i - 1) / 2 + j - 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; &#125; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;int main()&#123; int M[Matrix_Num * Matrix_Num]; int C[Matrix_Num * (Matrix_Num + 1) / 2]; int U[Matrix_Num * Matrix_Num]; input_Matrix(M); compress(M, C); uncompress_O1(C, U); //uncompress_On(C, U); //uncompress_On2(C, U); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验一]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !='' --2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001' --3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%' --4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc --5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号 --6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35 --7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001') --8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs --9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs --10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%' --12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20 --13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80 --14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业 --15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1) --16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5 --17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号 --19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别 --20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业 --21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/ --22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%' --23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号) select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号) --24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002') --25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1) --二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1' --2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno --3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200 --4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红') --5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400 --6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验二]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[问题描述1.第一次实验的顺序实现2.顺序栈的实现3.N个元素的序列的所有出栈可能1.第一次实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10#define ElemType int using namespace std;typedef struct &#123; ElemType *elem; int length; int listsize;&#125;SqList;void InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); L.length = 0; L.listsize = LIST_INIT_SIZE; return;&#125;int InputList_Sq(SqList &amp;L)&#123; ElemType n, temp; ElemType *p, *q; printf("请输入集合的元素个数：\n"); cin &gt;&gt; n; if (n &lt; 1 || n &gt; L.listsize) &#123; printf("输入有误\n"); return 0; &#125; if (L.length + n &gt;= L.listsize) &#123; L.elem = (ElemType*)realloc(L.elem, (L.length + n - L.listsize + LISTINCREMENT) * sizeof(ElemType)); L.listsize += (L.length + n - L.listsize + LISTINCREMENT); &#125; printf("请输入元素："); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q = &amp;(L.elem[i]); *q = temp; ++L.length; &#125; return 1;&#125;void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc)&#123; ElemType *pa, *pb, *pc, *pa_last, *pb_last; pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType*)malloc(Lc.listsize * sizeof(ElemType)); pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; if (*pa &lt; *pb) *pc++ = *pa++; else *pc++ = *pb++; &#125; while (pa &lt;= pa_last)*pc++ = *pa++; while (pb &lt;= pb_last)*pc++ = *pb++; return;&#125;void Show_Sq(SqList L, char name)&#123; int cnt = 0; printf("集合%c中的元素为：",name); for (int i = 0; i &lt; L.length; i++) &#123; if (L.elem[i] != L.elem[i + 1]) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; " "; cnt++; &#125; &#125; printf("去重后的元素个数为：%d\n", cnt); return;&#125;int main()&#123; SqList La, Lb, Lc; InitList_Sq(La); InitList_Sq(Lb); InitList_Sq(Lc); InputList_Sq(La); InputList_Sq(Lb); sort(La.elem, La.elem + La.length); sort(Lb.elem, Lb.elem + Lb.length); Show_Sq(La,'A'); Show_Sq(Lb,'B'); MergeList_Sq(La, Lb, Lc); Show_Sq(Lc,'C'); return 0;&#125; 2.顺序栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#define STACK_INIT_SIZE 100#define STACKINCREMENT 10#define SElemType intusing namespace std;typedef struct &#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return;&#125;int GetTop(SqStack S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *(S.top - 1); return 1;&#125;void Push(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top - S.base &gt;= S.stacksize) &#123; S.base = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return;&#125;int Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *--S.top; return 1;&#125;void Show(SqStack S)&#123; printf("栈中现有元素为： |"); for (auto it = S.base; it &lt; S.top; it++) cout &lt;&lt; *it &lt;&lt; " "; printf("\n"); return;&#125;int main()&#123; int p; SElemType x; SqStack S; InitStack(S); while (1) &#123; printf("请选择您要进行的操作(1代表Push 2代表Pop 0代表退出) ："); scanf("%d", &amp;p); if (p == 1) &#123; printf("请输入要压入栈中的元素："); cin &gt;&gt; x; Push(S, x); Show(S); &#125; else if (p == 2) &#123; SElemType e = 0; if (Pop(S, e)) &#123; printf("出栈元素为："); cout &lt;&lt; e &lt;&lt; endl; Show(S); &#125; else printf("栈中没有元素\n"); &#125; else &#123; Show(S); break; &#125; &#125; return 0;&#125; 3.所有出栈可能12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int total, res, sta, n;int r[2005], s[2005];void dfs(int m) &#123; if (m == n + 1) &#123; //若所有元素都入过栈，输出当前出栈序列 total++; for (int i = 1; i &lt;= res; i++) cout &lt;&lt; r[i] &lt;&lt; ' '; for (int i = sta; i &gt; 0; i--) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; if (sta &gt; 0) &#123; r[++res] = s[sta]; sta--; dfs(m); //栈顶元素出栈 s[++sta] = r[res]; res--; //回溯操作 &#125; s[++sta] = m; //当前元素入栈 dfs(m + 1); sta--; //回溯操作&#125;int main() &#123; printf("请输入元素个数："); scanf("%d", &amp;n); total = 0; res = 0; sta = 0; dfs(1); printf("共有%d种情况", total); return 0;&#125; 运行界面 顺序栈的实现 所有出栈可能]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验一]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题描述1.算法2.12.分别用链式和顺序表实现3.所涉及的基本操作全部用函数实现链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cstring&gt; typedef struct LNode &#123; int data; LNode *next;&#125;LNode,*LinkList;void List_initialize(LinkList &amp;L, int n)&#123; LNode* p; L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i)&#123; p = (LNode *)malloc(sizeof(LNode)); scanf("%d", &amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;bool compare(int a, int b)&#123; if (a == b) return true;&#125;void List_show(LNode *head)&#123; LNode *p = head-&gt;next; while (p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;int GetElem(LNode *L, int pos)&#123; LNode *p = L-&gt;next; for (int i = 0; i &lt; pos - 1; i++) p = p-&gt;next; return p-&gt;data;&#125;int Listlen(LNode *head)&#123; LNode *p = head-&gt;next; int len = 0; while (p)&#123; len++; p = p-&gt;next; &#125; return len;&#125;int List_insert(LinkList &amp;L, int i, int e)&#123; if (i &lt; 1) return 0; LNode *p = L; LNode *s; int j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p) return 0; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return 1;&#125;LNode* List_only(LNode *head)&#123; LNode *p, *q, *s; p = head-&gt;next; while (p-&gt;next != NULL)&#123; q = p; while (q-&gt;next != NULL)&#123; if (q-&gt;next-&gt;data == p-&gt;data)&#123; s = q-&gt;next; q-&gt;next = s-&gt;next; free(s); &#125; else q = q-&gt;next; &#125; p = p-&gt;next; &#125; return head;&#125;void List_union(LinkList &amp;L1, LinkList L2)&#123; LinkList p, q, s; p = L1; q = L2; while (p-&gt;next != NULL) &#123; while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data == q-&gt;next-&gt;data) break; else q = q-&gt;next; &#125; if (q-&gt;next == NULL) &#123; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = p-&gt;next-&gt;data; s-&gt;next = NULL; q-&gt;next = s; &#125; p = p-&gt;next; q = L2; &#125;&#125;int main()&#123; int lena, lenb; LinkList la, lb; printf("请输入集合A的元素个数："); scanf("%d", &amp;lena); printf("请输入集合A元素："); List_initialize(la, lena); printf("原集合A："); List_show(la); printf("\n"); List_only(la); printf("集合去重后个数："); printf("%d",Listlen(la)); printf("\n"); printf("删除重复元素后的集合A为："); List_show(la); printf("\n"); printf("请输入集合B的元素个数："); scanf("%d", &amp;lenb); printf("请输入集合B元素："); List_initialize(lb, lenb); printf("集合B："); List_show(lb); printf("\n"); List_only(lb); printf("集合去重后个数："); printf("%d", Listlen(lb)); printf("\n"); printf("删除重复元素后的集合B为："); List_show(lb); printf("\n"); printf("A和B的并集为："); List_union(la, lb); List_only(la); List_show(la); return 0;&#125; 运行界面 顺序表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000], b[10000];int lena, lenb;void arrayA_initialize()&#123; //输入集合A printf("请输入集合元素个数(小于10000)："); scanf("%d", &amp;lena); while (lena &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合A元素个数(小于10000)："); scanf("%d", &amp;lena); &#125; printf("请输入集合A元素："); int temp, cnta = 1; scanf("%d", &amp;a[0]); for (int i = 1; i &lt; lena; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == a[j]) flag = 0; &#125; if (flag) &#123; a[cnta] = temp; cnta++; &#125; &#125; lena = cnta; printf("数组A的长度最终为： %d\n", lena); printf("去重后的数组A为 ：\n"); for (int i = 0; i &lt; lena; i++) printf("%d ", a[i]); printf("\n");&#125;void arrayB_initialize()&#123; //输入集合B printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); while (lenb &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); &#125; printf("请输入集合B元素："); int temp, cntb = 1; scanf("%d", &amp;b[0]); for (int i = 1; i &lt; lenb; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == b[j]) flag = 0; &#125; if (flag) &#123; b[cntb] = temp; cntb++; &#125; &#125; lenb = cntb; printf("数组B的长度最终为： %d\n", lenb); printf("去重后的数组B为 ：\n"); for (int i = 0; i &lt; lenb; i++) printf("%d ", b[i]); printf("\n");&#125;int binarySearch(int a[], int b, int lena) &#123; int left = 0, right = lena - 1, mid; while (left &lt;= right)&#123; mid = (right + left) / 2; if (a[mid] == b) return 1; else if (a[mid] &gt; b)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; return -1; &#125;void array_insert(int a[], int lena, int b[], int lenb)&#123; //将所有在数组B中但不在A中的数据元素插入到A中 int cnt = 0; for (int i = 0; i &lt; lenb; i++) &#123; if (binarySearch(a, b[i], lena) == -1) &#123; a[lena + cnt] = b[i]; cnt++; &#125; &#125; lena += cnt; printf("A与B合并后的集合为：\n"); for (int i = 0; i &lt; lena; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main()&#123; arrayA_initialize(); arrayB_initialize(); array_insert(a, lena, b, lenb); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
</search>

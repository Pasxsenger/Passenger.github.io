<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1001 A+B Format]]></title>
    <url>%2F2019%2F10%2F28%2FPTA-Advanced-Level-1001-A-B-Format%2F</url>
    <content type="text"><![CDATA[Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6≤a,b≤10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input： 1-1000000 9 Sample Output: 1-999,991 Solution12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt; using namespace std; int main()&#123; int a, b, c, ans[10], flag = 0, n = 1; scanf("%d%d", &amp;a, &amp;b); c = a + b; if (c == 0) &#123; //第一次提交没有想到a+b为0这一点 printf("0"); return 0; &#125; if (c &gt; 0) //determine the positive and negative flag = 1; c = abs(c); while (c) &#123; //convert the sum into an array ans[n++] = c % 10; c /= 10; &#125; if (flag == 0) printf("-"); for (int i = n - 1; i &gt; 0; i--) &#123; if (i % 3 == 0 &amp;&amp; i != n - 1) printf(","); printf("%d", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验四]]></title>
    <url>%2F2019%2F10%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229--一、对xsgl数据库完成下列操作要求：use xsgl--1.将被全部学生都选修了的课程的总学分改为4学分update kc set kc.学分 = 4where kc.课程号 in (select kc.课程号 from kc where not exists (select * from xs where not exists (select * from cj where cj.课程号 = kc.课程号 and cj.学号 = xs.学号)))--2.从学生表删除没有选课的学生delete from xswhere xs.学号 not in (select cj.学号 from cj)--3.将每个学生的平均分，总分和选课门数插入到数据库中（学号，姓名，平均分，总分，选课门数）create table new(学号 char(10),姓名 nchar(10),平均分 numeric(10,2),总分 numeric(10,2),选课门数 smallint)insert into newselect xs.学号,xs.姓名,avg(cj.成绩),sum(cj.成绩),count(cj.课程号)from xs left join cj on xs.学号=cj.学号group by xs.学号,xs.姓名--4.创建每门课程的平均分和选课人数的视图（课程号，课程名，平均分，人数）create view Course(课程号,课程名,平均分,人数)asselect kc.课程号,kc.课程名,avg(cj.成绩) 平均分,count(cj.学号) 人数from kc left join cj on (kc.课程号 = cj.课程号)group by kc.课程号,kc.课程名--5.将李强同学从学生表删除（提示应该先删除李强同学的选课记录）delete from cjwhere cj.学号 = (select xs.学号 from xs where xs.姓名 = '李强')delete from xswhere xs.姓名 = '李强'--6.插入一条选课记录（具体内容自己选）insertinto xsvalues('2018008003','彭于晏','男',null,null,null,null,null)insertinto cjvalues('2018008003','A001',null)--7.创建网络工程专业的学生的选课信息的视图，要求视图包含，学号，姓名，专业，课程号，课程名，成绩create view IT(学号,姓名,专业,课程号,课程名,成绩)asselect xs.学号,xs.姓名,xs.专业,kc.课程号,kc.课程名,cj.成绩from xs left join cj on xs.学号 = cj.学号 right join kc on cj.课程号 = kc.课程号where xs.专业 = '网络工程'--8.查询网络工程专业的各科的平均成绩，要求使用第7题创建的视图进行查询select IT.课程号,avg(IT.成绩) 平均成绩from ITgroup by IT.课程号--9.查询被信息管理专业的学生都选修了的课程的课程号，课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from xs where xs.专业 = '信息管理' and not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--10.显示选修课程数最多的学号及选修课程数最少的学号，姓名（使用派生表实现）select xs.学号,xs.姓名,count(*) 门数from xs,cj,(select top 1 count(*) from cj group by cj.学号 order by count(*) desc) Maxx(门数), (select top 1 count(*) from cj group by cj.学号 order by count(*)) Minn(门数)where cj.学号 = xs.学号group by xs.学号,xs.姓名,Maxx.门数,Minn.门数having count(*) = Maxx.门数 or count(*) = Minn.门数--11.查询每个学生成绩高于自己的平均成绩的学号，姓名，课程号和成绩（使用派生表实现）select xs.学号,xs.姓名,cj.课程号,cj.成绩from xs,cj,(select cj1.学号,avg(cj1.成绩) 平均成绩 from cj cj1 group by cj1.学号) avg_gradewhere cj.学号 = avg_grade.学号 and xs.学号 = cj.学号 and cj.成绩 &gt; avg_grade.平均成绩--12.自己验证with check option的作用create view IEasselect xs.学号,xs.姓名,xs.性别,xs.专业from xswhere xs.专业 = '网络工程'with check optioninsert into IE(学号,姓名)values('2018008002','吴彦祖') --13.创建一个网络工程系的学生基本信息的视图MA_STUDENT，在此视图的基础上，再定义一个该专业女生信息的视图，然后再删除MA_STUDENT，观察执行情况。create view MA_STUDENTasselect *from xswhere xs.专业 = '网络工程'with check optioncreate view Femaleasselect *from MA_STUDENTwhere MA_STUDENT.性别 = '女'drop view MA_STUDENT--14.查询和程明同龄的学生的学号和姓名以及年龄select xs.学号,xs.姓名,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) = (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.姓名 = '程明')--15.查询没有被全部的学生都选修的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere exists (select * from xs where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--16.查询选课学生包含了选英语的全部学生的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from cj where cj.课程号 = (select kc.课程号 from kc where kc.课程名 = '英语') and not exists (select * from cj c where c.学号 = cj.学号 and c.课程号 = kc.课程号))--二、使用Northwind数据库完成下列操作use Northwind--1. 将员工lastname是: Peacock处理的订单中购买数量超过50的商品折扣改为七折update [Order Details]set Discount = 0.3where [Order Details].Quantity &gt; 50 and [Order Details].OrderID in (select O1.OrderID from [Order Details] O1,Employees,Orders where Employees.EmployeeID = Orders.EmployeeID and Orders.OrderID = O1.OrderID and Employees.LastName = 'Peacock' and O1.Quantity &gt; 50)--2. 删除lastname是: Peacock处理的所有订单deletefrom [Order Details]where [Order Details].OrderID in (select distinct O1.OrderID from [Order Details] O1,Employees,Orders where O1.OrderID = Orders.OrderID and Orders.EmployeeID = Employees.EmployeeID and Employees.LastName = 'Peacock')deletefrom Orderswhere Orders.EmployeeID = (select Employees.EmployeeID from Employees where Employees.LastName = 'Peacock')--3. 将每个订单的订单编号，顾客编号，产品总数量，总金额插入到数据库中create table OrderInfo(订单编号 int,顾客编号 nchar(5),产品总数量 smallint,总金额 money)insertinto OrderInfoselect Orders.OrderID,Orders.CustomerID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1- [Order Details].Discount)) 金额from [Order Details],Orderswhere [Order Details].OrderID = Orders.OrderIDgroup by Orders.OrderID,Orders.CustomerID--4. 插入一个新的订单，要求该订单购买了商品编号为5,7,9的商品。（5号商品买了10个，7号买了20个，9号买了15个，都没有折扣）insert into [Order Details]values('10325','5', '50', '10', '0')insert into [Order Details]values('10325','7', '70', '20', '0')insert into [Order Details]values('10325','9', '90', '15', '0')--5. 将每年每个员工处理订单的数量和订单的总金额创建为视图create view Employasselect Employees.EmployeeID,datename(yy,Orders.OrderDate) 年份, count(distinct Orders.OrderID) 订单数量,sum([Order Details].Quantity) 数量, sum([Order Details].Quantity*[Order Details].UnitPrice*(1-[Order Details].Discount)) 订单总金额from Employees left join Orders on Employees.EmployeeID=Orders.EmployeeID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Employees.EmployeeID,datename(yy,Orders.OrderDate)--6. 购买了CustomerID是‘VINET’用户所购买的全部商品的用户的CustomerID和CompanyName。select distinct Customers.CustomerID,Customers.CompanyNamefrom Customers,Orders where Customers.CustomerID = Orders.CustomerID and not exists (select * from Orders o2,Customers c2 where o2.CustomerID = c2.CustomerID and o2.CustomerID = 'VINET' and not exists (select * from Orders o3 where o3.CustomerID = Orders.CustomerID))]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验三]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337--一.对xsgl数据库完成以下操作--1.查询没有选修英语的学生的学号，姓名和课程号，课程名，成绩select xs.学号,xs.姓名,kc.课程号,kc.课程名,cj.成绩from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号 and kc.课程名 &lt;&gt; '英语'--2.查询英语成绩高于英语的平均成绩的学生的学号，姓名，成绩select xs.学号,xs.姓名,cj.成绩from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.成绩 &gt; (select avg(cj.成绩) from kc,cj where cj.课程号 = kc.课程号 and kc.课程名 = '英语')--3.查询选修了英语和高数(数学)的学生的学号和姓名（要求使用两种方法实现）select xs.学号,xs.姓名from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.学号 in (select cj.学号 from cj,xs,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '数学')select xs.学号,xs.姓名from xs,cj,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and 课程名 = '英语' and xs.学号 in (select 学号 from cj where 课程号 = (select 课程号 from kc where 课程名 = '数学'))--4.查询没有选修程明所选修的全部课程的学生的姓名select xs.姓名from xs,cjwhere xs.学号 = cj.学号 and cj.课程号 not in (select cj.课程号 from xs,cj where xs.学号 = cj.学号 and xs.姓名 = '程明')--5.查询每个专业年龄超过该专业平均年龄的学生的姓名和专业select xs1.姓名,xs1.专业from xs xs1where datediff(yy,xs1.出生时间,getdate()) &gt; (select avg(datediff(yy,xs2.出生时间,getdate())) from xs xs2 where xs1.专业 = xs2.专业)--6.查询每个专业每门课程的专业，课程号，课程名，选课人数，平均分和最高分select xs.专业,kc.课程号,kc.课程名,count(*) 选课人数,avg(cj.成绩) 平均分,max(cj.成绩) 最高分from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号group by kc.课程号,kc.课程名,xs.专业--7.查询每个学生取得最高分的课程的课程号，课程名和成绩select cj.学号,kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.成绩 &gt;= all (select cj2.成绩 from cj cj2 where cj2.学号 = cj.学号)--8.查询每个专业年龄最高的学生的学号，姓名，专业和年龄select xs.学号,xs.姓名,xs.专业,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) &gt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = xs.专业)--9.查询没有选修数据结构和操作系统的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.学号 not in (select cj.学号 from cj where cj.课程号 in (select kc.课程号 from kc where kc.课程名 = '数据结构' or kc.课程名 = '操作系统'))--10.查询网络工程专业年龄最小的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.专业 = '网络工程' and datediff(yy,xs.出生时间,getdate()) &lt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = '网络工程')--11.查询选课人数超过5人的课程的课程号，课程名和成绩select kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.课程号 in (select cj2.课程号 from cj cj2 group by cj2.课程号 having count(cj2.学号) &gt; 5)--12.查询选修了全部课程的学生的学号和姓名（用两种方法实现）select xs.学号,xs.姓名from xswhere not exists (select * from kc where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))select xs.学号,xs.姓名from xswhere xs.学号 in (select cj.学号 from cj group by cj.学号 having count(*) = (select count(*) from kc))--13.查询选课人数最多的课程号和课程名（包含并列）select cj.课程号,kc.课程名from kc,cjwhere kc.课程号 = cj.课程号group by cj.课程号,kc.课程名having count(*) &gt;= all (select count(*) from cj cj2 group by cj2.课程号)--14.查询选修了程明所选修的全部课程的学生的姓名select distinct xs.姓名from xs,cj where xs.学号 = cj.学号 and not exists (select * from cj cj2,xs xs2 where xs2.学号 = cj2.学号 and xs2.姓名 = '程明' and not exists (select * from cj cj3 where cj3.学号 = cj.学号 and cj 3.课程号 = cj2.课程号))--二．对罗斯文数据库完成一下查询--15.查询每个订单购买产品的数量和总金额，显示订单号，数量，总金额select [Order Details].OrderID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details]group by [Order Details].OrderID--16.查询每个员工在7月份处理订单的数量select count(Orders.OrderID) 订单数量from Orders right join Employees on (Employees.EmployeeID = Orders.EmployeeID)where month(Orders.OrderDate) = '07'group by Employees.EmployeeID--17.查询每个顾客的订单总数，显示顾客ID，订单总数select Customers.CustomerID,count(Orders.OrderID) 订单总数from Orders right join Customers on (Customers.CustomerID = Orders.CustomerID)group by Customers.CustomerID--18.查询每个顾客的订单总数和订单总金额select Customers.CustomerID,count(distinct Orders.OrderID) 订单总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from Orders right join Customers on Orders.CustomerID=Customers.CustomerID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Customers.CustomerID--19.查询每种产品的卖出总数和总金额select sum([Order Details].Quantity) 卖出总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details] right join Products on ([Order Details].ProductID = Products.ProductID)group by Products.ProductID--20.查询购买过全部商品的顾客的ID和姓名select Customers.CustomerID,Customers.ContactNamefrom Customerswhere not exists (select * from Products where not exists (select * from Orders,[Order Details] where Orders.OrderID = [Order Details].OrderID and Products.ProductID = [Order Details].ProductID and Customers.CustomerID = Orders.CustomerID))--三.对books数据库完成以下操作--21.查询各种类别的图书的类别和数量（包含目前没有图书的类别）select BookType.TypeName,count(BookInfo.TypeID) 数量from BookType left join BookInfo on (BookType.TypeID = BookInfo.TypeID)group by BookType.TypeName--22.查询借阅了‘数据库基础’的读者的卡编号和姓名select BorrowInfo.CardNo,CardInfo.Readerfrom BorrowInfo,CardInfo,BookInfowhere BorrowInfo.BookNo = BookInfo.BookNo and BorrowInfo.CardNo = CardInfo.CardNo and BookInfo.BookName = '数据库基础'--23.查询各个出版社的图书价格超过这个出版社图书的平均价格的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.Price &gt; (select avg(b1.Price) from BookInfo b1 where BookInfo.Publisher = b1.Publisher)--24.查询没有借过图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere CardInfo.CardNo not in (select BorrowInfo.CardNo from BorrowInfo)--25.查询借阅次数超过2次的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfo,BorrowInfowhere CardInfo.CardNo = BorrowInfo.CardNogroup by CardInfo.CardNo,CardInfo.Readerhaving count(BorrowInfo.CardNo) &gt; 2--26.查询借阅卡的类型为老师和研究生的读者人数select count(CardInfo.CardNo) 读者人数from CardType,CardInfowhere CardInfo.CTypeID = CardType.CTypeID and (CardType.TypeName = '教师' or CardType.TypeName = '研究生')--27.查询没有被借过的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.BookNo not in (select BorrowInfo.BookNo from BorrowInfo)--28.查询没有借阅过英语类型的图书的学生的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo,BorrowInfo,BookType,CardType where BookType.TypeName='英语' and CardType.TypeName = '学生' and CardType.CTypeID = CardInfo.CTypeID and BookType.TypeID=BookInfo.TypeID and BookInfo.BookNo=BorrowInfo.BookNo and BorrowInfo.CardNo=CardInfo.CardNo)--29.查询借阅了‘计算机应用’类别的‘数据库基础’课程的学生的编号读者以及该读者的借阅卡的类型select CardInfo.CardNo,CardType.TypeNamefrom CardInfo,CardType,BorrowInfowhere CardInfo.CTypeID = CardType.CTypeID and BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo in (select BookInfo.BookNo from BookInfo where BookInfo.BookName = '数据库基础')--30.查询借阅过了全部图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo where not exists (select * from BorrowInfo where BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo = BookInfo.BookNo))--四．对商场数据库完成以下操作--Market (mno, mname, city)--Item (ino, iname, type, color)--Sales (mno, ino, price)--其中，market表示商场，它的属性依次为商场号、商场名和所在城市；item表示商品，它的属性依次为商品号、商品名、商品类别和颜色；sales表示销售，它的属性依次为商场号、商品号和售价。用SQL语句实现下面的查询要求：--1.列出北京各个商场都销售，且售价均超过10000 元的商品的商品号和商品名select item.ino,item.inamefrom itemwhere not exists (select * from sales,market where sales.mno = market.mno and market.city = '北京' and not exists (select * from sales s1 where s1.ino = item.ino and s1.mno = sales.mno and s1.price &gt; 10000))--2.列出在不同商场中最高售价和最低售价只差超过100 元的商品的商品号、最高售价和最低售价select sales.ino,max(sales.price) 最高售价,min(sales.price) 最低售价from salesgroup by sales.inohaving max(sales.price) - min(sales.price) &gt; 100--3.列出售价超过该商品的平均售价的各个商品的商品号和售价select sales.ino,sales.pricefrom saleswhere sales.price &gt; (select avg(s2.price) from sales s2 where s2.ino = sales.ino)--4.查询每个每个城市各个商场售价最高的商品的商场名，城市，商品号和商品名select market.mname,market.city,sales.ino,item.inamefrom market,sales,itemwhere market.mno = sales.mno and item.ino = sales.ino and sales.price &gt;= all (select s2.price from sales s2 where s2.mno = sales.mno)--5.查询销售商品数量最多的商场的商场号，商场名和城市select market.mno,market.mname,market.cityfrom market,saleswhere market.mno = sales.mnogroup by market.mno,market.mname,market.cityhaving count(sales.ino) &gt;= all (select count(s2.ino) from sales s2 group by s2.mno)--6.查询销售了冰箱和洗衣机的商场号，商场名和城市select distinct market.mno,market.mname,market.cityfrom market,saleswhere market.mno in (select s1.mno from sales s1 where s1.ino in (select item.ino from item where item.iname = '冰箱') and s1.mno in (select s2.mno from sales s2 where s2.ino in (select item.ino from item where item.iname = '洗衣机')))--7.查询所有商场都销售了的商品的商品号和商品名。（用两种方法实现）select item.ino,item.inamefrom itemwhere not exists (select * from market where not exists (select * from sales where sales.mno = market.mno and sales.ino = item.ino))select item.ino,item.inamefrom item,saleswhere item.ino = sales.inogroup by sales.ino, item.ino,item.inamehaving count(sales.mno) = (select count(market.mno) from market)]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验二]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !=''--2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001'--3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%'--4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc--5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号--6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35--7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001')--8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs--9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs--10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%'--12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20--13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80--14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业--15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1)--16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5--17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号--19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别--20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业--21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/--22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%'--23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号)select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号)--24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002')--25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1)--二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1'--2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno--3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200--4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红')--5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400--6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验四]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[问题描述对一个稀疏矩阵进行转置要求用十字链表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct OLNode&#123; int i, j; ElemType e; struct OLNode *right, *down;&#125;OLNode, *OLink;typedef struct CrossList&#123; OLink *rhead, *chead; int mu, nu, tu;&#125;CrossList, *pCrossList;void CreateSMatrix_OL(pCrossList M)&#123; //输入行数列数以及非零元个数 printf("请输入行数，列数，非零元素个数：\n"); scanf("%d%d%d", &amp;M-&gt;mu, &amp;M-&gt;nu, &amp;M-&gt;tu); if (M-&gt;tu * 20 &gt; M-&gt;mu * M-&gt;nu) printf("非稀疏矩阵，不建议使用此方法！\n"); //动态申请行和列指针数组 M-&gt;rhead = (OLink *)malloc(sizeof(OLink)*M-&gt;mu); if (M-&gt;rhead == NULL) return; M-&gt;chead = (OLink *)malloc(sizeof(OLink)*M-&gt;nu); if (M-&gt;chead == NULL)&#123; free(M-&gt;rhead); return; &#125; //初始化两个数组 int i, j; for (i = 1; i &lt;= M-&gt;mu; i++) M-&gt;rhead[i] = NULL; for (j = 1; j &lt;= M-&gt;nu; j++) M-&gt;chead[j] = NULL; //创建节点并连接到十字链表上 for (i = 1; i &lt;= M-&gt;tu; i++)&#123; OLink p = (OLink)malloc(sizeof(OLNode)); if (p == NULL) return; printf("请输入非零元素的行，列，值\n"); scanf("%d%d%d", &amp;p-&gt;i, &amp;p-&gt;j, &amp;p-&gt;e); p-&gt;down = NULL; p-&gt;right = NULL; //连接行 //如果该行并没有连接任何节点（NULL）或者该行连接的第一个节点的列值大于当前待连接的节点则直接将当前节点连接到该行第一个节点的位置 if (M-&gt;rhead[p-&gt;i] == NULL || M-&gt;rhead[p-&gt;i]-&gt;j &gt; p-&gt;j)&#123; p-&gt;right = M-&gt;rhead[p-&gt;i]; M-&gt;rhead[p-&gt;i] = p; &#125; //否则遍历该行找到合适的位置插入 else &#123; OLink q = M-&gt;rhead[p-&gt;i];//指向第一个节点，从第一个节点开始遍历 while (q-&gt;right != NULL &amp;&amp; q-&gt;right-&gt;j &lt; p-&gt;j)//遍历到前一个节点 q = q-&gt;right; p-&gt;right = q-&gt;right; q-&gt;right = p; &#125; //连接列 if (M-&gt;chead[p-&gt;j] == NULL || M-&gt;chead[p-&gt;j]-&gt;i &gt; p-&gt;i) &#123; p-&gt;down = M-&gt;chead[p-&gt;j]; M-&gt;chead[p-&gt;j] = p; &#125; else &#123; OLink pNodeTravel = M-&gt;chead[p-&gt;j]; while (pNodeTravel-&gt;down != NULL &amp;&amp; pNodeTravel-&gt;down-&gt;i &lt; p-&gt;i) pNodeTravel = pNodeTravel-&gt;down; p-&gt;down = pNodeTravel-&gt;down; pNodeTravel-&gt;down = p; &#125; &#125;&#125;void TransSMatrix_OL(CrossList M, CrossList *T)&#123; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; //Q的头节点的初始化 if (!(T-&gt;rhead = (OLink *)malloc((T-&gt;mu + 1) * sizeof(OLink)))) &#123;printf("内存空间申请失败！");return;&#125; if (!(T-&gt;chead = (OLink *)malloc((T-&gt;nu + 1) * sizeof(OLink)))) &#123; printf("内存空间申请失败！"); return; &#125; for (int i = 1; i &lt;= T-&gt;mu; i++) T-&gt;rhead[i] = NULL; for (int i = 1; i &lt;= T-&gt;nu; i++) T-&gt;chead[i] = NULL; if (!M.tu) return; OLink p, q, q_row, q_col; for (int i = 1; i &lt;= M.nu; i++)&#123; if (M.chead[i]) &#123; for (q = M.chead[i]; q;) &#123; if (!(p = (OLink)malloc(sizeof(OLNode))))&#123; printf("内存空间申请失败！"); return; &#125; p-&gt;i = q-&gt;j; p-&gt;j = q-&gt;i; p-&gt;e = q-&gt;e; p-&gt;right = p-&gt;down = NULL; q_row = T-&gt;rhead[i]; if (NULL == T-&gt;rhead[i]) T-&gt;rhead[i] = p; else &#123; while (q_row-&gt;right) q_row = q_row-&gt;right; q_row-&gt;right = p; &#125; q_col = T-&gt;chead[p-&gt;j]; if (T-&gt;chead[p-&gt;j] == NULL) T-&gt;chead[p-&gt;j] = p; else &#123; while (q_col-&gt;down) q_col = q_col-&gt;down; q_col-&gt;down = p; &#125; q = q-&gt;down; &#125; &#125; &#125; return;&#125;void OutputSMatrix_OL(pCrossList M, char s[])&#123; int i, j; OLink p; printf("----------------------\n"); printf("%s矩阵为：\n", s); for (i = 1; i &lt;= M-&gt;mu; i++)&#123; p = M-&gt;rhead[i]; for (j = 1; j &lt;= M-&gt;nu; j++)&#123; if (p != NULL &amp;&amp; p-&gt;j == j) &#123; printf("%d ", p-&gt;e); p = p-&gt;right; &#125; else printf("0 "); &#125; printf("\n"); &#125; printf("----------------------\n"); printf("\n"); return;&#125;int main()&#123; CrossList M, T; CreateSMatrix_OL(&amp;M); char s1[] = "原始"; OutputSMatrix_OL(&amp;M, s1); TransSMatrix_OL(M, &amp;T); char s2[] = "转置后"; OutputSMatrix_OL(&amp;T, s2); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验三]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[问题描述对一个对称矩阵进行压缩及解压缩注意 压缩时： 第一步：完整地显示矩阵 第二步： 完整地显示一维数组 ——————————————————————————————————————— 解压缩时： 第一步：完整地显示一维数组 第二步：完整地显示矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define Matrix_Num 5void input_Matrix(int *Matrix)&#123; printf("输入方阵：\n"); for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; scanf("%d", &amp;Matrix[Matrix_Num * i + j]); &#125; &#125; printf("\n"); return;&#125;void show1D(int Compressed[])&#123; for (int i = 0; i &lt; Matrix_Num*(Matrix_Num + 1) / 2; i++) printf("%d ", Compressed[i]); printf("\n"); return;&#125;void show2D(int Matrix[])&#123; for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; printf("%d ", Matrix[Matrix_Num*i + j]); &#125; printf("\n"); &#125; return;&#125;void compress(int Matrix[],int *Compressed)&#123; int n = 0; printf("您输入的方阵为：\n"); show2D(Matrix); printf("压缩后\n"); for (int i = 0; i &lt; Matrix_Num; i++) for (int j = 0; j &lt;= i; j++) Compressed[n++] = Matrix[Matrix_Num*i + j]; show1D(Compressed); printf("\n"); return;&#125;void uncompress_O1(int Compressed[],int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; int i, j; i = ceil(sqrt(2.25 + 2 * k) - 0.5); j = k - i * (i - 1) / 2; i--; Uncompressed[Matrix_Num*i + j] = Compressed[k]; Uncompressed[Matrix_Num*j + i] = Compressed[k]; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; int j = k - i * (i - 1) / 2 + 1; if (i &gt;= j &amp;&amp; j &gt;= 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; break; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On2(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (k == i * (i - 1) / 2 + j - 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; &#125; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;int main()&#123; int M[Matrix_Num * Matrix_Num]; int C[Matrix_Num * (Matrix_Num + 1) / 2]; int U[Matrix_Num * Matrix_Num]; input_Matrix(M); compress(M, C); uncompress_O1(C, U); //uncompress_On(C, U); //uncompress_On2(C, U); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验一]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !='' --2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001' --3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%' --4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc --5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号 --6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35 --7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001') --8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs --9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs --10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%' --12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20 --13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80 --14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业 --15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1) --16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5 --17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号 --19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别 --20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业 --21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/ --22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%' --23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号) select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号) --24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002') --25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1) --二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1' --2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno --3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200 --4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红') --5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400 --6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验二]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[问题描述1.第一次实验的顺序实现2.顺序栈的实现3.N个元素的序列的所有出栈可能1.第一次实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10#define ElemType int using namespace std;typedef struct &#123; ElemType *elem; int length; int listsize;&#125;SqList;void InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); L.length = 0; L.listsize = LIST_INIT_SIZE; return;&#125;int InputList_Sq(SqList &amp;L)&#123; ElemType n, temp; ElemType *p, *q; printf("请输入集合的元素个数：\n"); cin &gt;&gt; n; if (n &lt; 1 || n &gt; L.listsize) &#123; printf("输入有误\n"); return 0; &#125; if (L.length + n &gt;= L.listsize) &#123; L.elem = (ElemType*)realloc(L.elem, (L.length + n - L.listsize + LISTINCREMENT) * sizeof(ElemType)); L.listsize += (L.length + n - L.listsize + LISTINCREMENT); &#125; printf("请输入元素："); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q = &amp;(L.elem[i]); *q = temp; ++L.length; &#125; return 1;&#125;void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc)&#123; ElemType *pa, *pb, *pc, *pa_last, *pb_last; pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType*)malloc(Lc.listsize * sizeof(ElemType)); pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; if (*pa &lt; *pb) *pc++ = *pa++; else *pc++ = *pb++; &#125; while (pa &lt;= pa_last)*pc++ = *pa++; while (pb &lt;= pb_last)*pc++ = *pb++; return;&#125;void Show_Sq(SqList L, char name)&#123; int cnt = 0; printf("集合%c中的元素为：",name); for (int i = 0; i &lt; L.length; i++) &#123; if (L.elem[i] != L.elem[i + 1]) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; " "; cnt++; &#125; &#125; printf("去重后的元素个数为：%d\n", cnt); return;&#125;int main()&#123; SqList La, Lb, Lc; InitList_Sq(La); InitList_Sq(Lb); InitList_Sq(Lc); InputList_Sq(La); InputList_Sq(Lb); sort(La.elem, La.elem + La.length); sort(Lb.elem, Lb.elem + Lb.length); Show_Sq(La,'A'); Show_Sq(Lb,'B'); MergeList_Sq(La, Lb, Lc); Show_Sq(Lc,'C'); return 0;&#125; 2.顺序栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#define STACK_INIT_SIZE 100#define STACKINCREMENT 10#define SElemType intusing namespace std;typedef struct &#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return;&#125;int GetTop(SqStack S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *(S.top - 1); return 1;&#125;void Push(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top - S.base &gt;= S.stacksize) &#123; S.base = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return;&#125;int Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *--S.top; return 1;&#125;void Show(SqStack S)&#123; printf("栈中现有元素为： |"); for (auto it = S.base; it &lt; S.top; it++) cout &lt;&lt; *it &lt;&lt; " "; printf("\n"); return;&#125;int main()&#123; int p; SElemType x; SqStack S; InitStack(S); while (1) &#123; printf("请选择您要进行的操作(1代表Push 2代表Pop 0代表退出) ："); scanf("%d", &amp;p); if (p == 1) &#123; printf("请输入要压入栈中的元素："); cin &gt;&gt; x; Push(S, x); Show(S); &#125; else if (p == 2) &#123; SElemType e = 0; if (Pop(S, e)) &#123; printf("出栈元素为："); cout &lt;&lt; e &lt;&lt; endl; Show(S); &#125; else printf("栈中没有元素\n"); &#125; else &#123; Show(S); break; &#125; &#125; return 0;&#125; 3.所有出栈可能12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int total, res, sta, n;int r[2005], s[2005];void dfs(int m) &#123; if (m == n + 1) &#123; //若所有元素都入过栈，输出当前出栈序列 total++; for (int i = 1; i &lt;= res; i++) cout &lt;&lt; r[i] &lt;&lt; ' '; for (int i = sta; i &gt; 0; i--) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; if (sta &gt; 0) &#123; r[++res] = s[sta]; sta--; dfs(m); //栈顶元素出栈 s[++sta] = r[res]; res--; //回溯操作 &#125; s[++sta] = m; //当前元素入栈 dfs(m + 1); sta--; //回溯操作&#125;int main() &#123; printf("请输入元素个数："); scanf("%d", &amp;n); total = 0; res = 0; sta = 0; dfs(1); printf("共有%d种情况", total); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验一]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题描述1.算法2.12.分别用链式和顺序表实现3.所涉及的基本操作全部用函数实现链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cstring&gt; typedef struct LNode &#123; int data; LNode *next;&#125;LNode,*LinkList;void List_initialize(LinkList &amp;L, int n)&#123; LNode* p; L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i)&#123; p = (LNode *)malloc(sizeof(LNode)); scanf("%d", &amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;bool compare(int a, int b)&#123; if (a == b) return true;&#125;void List_show(LNode *head)&#123; LNode *p = head-&gt;next; while (p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;int GetElem(LNode *L, int pos)&#123; LNode *p = L-&gt;next; for (int i = 0; i &lt; pos - 1; i++) p = p-&gt;next; return p-&gt;data;&#125;int Listlen(LNode *head)&#123; LNode *p = head-&gt;next; int len = 0; while (p)&#123; len++; p = p-&gt;next; &#125; return len;&#125;int List_insert(LinkList &amp;L, int i, int e)&#123; if (i &lt; 1) return 0; LNode *p = L; LNode *s; int j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p) return 0; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return 1;&#125;LNode* List_only(LNode *head)&#123; LNode *p, *q, *s; p = head-&gt;next; while (p-&gt;next != NULL)&#123; q = p; while (q-&gt;next != NULL)&#123; if (q-&gt;next-&gt;data == p-&gt;data)&#123; s = q-&gt;next; q-&gt;next = s-&gt;next; free(s); &#125; else q = q-&gt;next; &#125; p = p-&gt;next; &#125; return head;&#125;void List_union(LinkList &amp;L1, LinkList L2)&#123; LinkList p, q, s; p = L1; q = L2; while (p-&gt;next != NULL) &#123; while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data == q-&gt;next-&gt;data) break; else q = q-&gt;next; &#125; if (q-&gt;next == NULL) &#123; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = p-&gt;next-&gt;data; s-&gt;next = NULL; q-&gt;next = s; &#125; p = p-&gt;next; q = L2; &#125;&#125;int main()&#123; int lena, lenb; LinkList la, lb; printf("请输入集合A的元素个数："); scanf("%d", &amp;lena); printf("请输入集合A元素："); List_initialize(la, lena); printf("原集合A："); List_show(la); printf("\n"); List_only(la); printf("集合去重后个数："); printf("%d",Listlen(la)); printf("\n"); printf("删除重复元素后的集合A为："); List_show(la); printf("\n"); printf("请输入集合B的元素个数："); scanf("%d", &amp;lenb); printf("请输入集合B元素："); List_initialize(lb, lenb); printf("集合B："); List_show(lb); printf("\n"); List_only(lb); printf("集合去重后个数："); printf("%d", Listlen(lb)); printf("\n"); printf("删除重复元素后的集合B为："); List_show(lb); printf("\n"); printf("A和B的并集为："); List_union(la, lb); List_only(la); List_show(la); return 0;&#125; 顺序表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000], b[10000];int lena, lenb;void arrayA_initialize()&#123; //输入集合A printf("请输入集合元素个数(小于10000)："); scanf("%d", &amp;lena); while (lena &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合A元素个数(小于10000)："); scanf("%d", &amp;lena); &#125; printf("请输入集合A元素："); int temp, cnta = 1; scanf("%d", &amp;a[0]); for (int i = 1; i &lt; lena; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == a[j]) flag = 0; &#125; if (flag) &#123; a[cnta] = temp; cnta++; &#125; &#125; lena = cnta; printf("数组A的长度最终为： %d\n", lena); printf("去重后的数组A为 ：\n"); for (int i = 0; i &lt; lena; i++) printf("%d ", a[i]); printf("\n");&#125;void arrayB_initialize()&#123; //输入集合B printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); while (lenb &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); &#125; printf("请输入集合B元素："); int temp, cntb = 1; scanf("%d", &amp;b[0]); for (int i = 1; i &lt; lenb; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == b[j]) flag = 0; &#125; if (flag) &#123; b[cntb] = temp; cntb++; &#125; &#125; lenb = cntb; printf("数组B的长度最终为： %d\n", lenb); printf("去重后的数组B为 ：\n"); for (int i = 0; i &lt; lenb; i++) printf("%d ", b[i]); printf("\n");&#125;int binarySearch(int a[], int b, int lena) &#123; int left = 0, right = lena - 1, mid; while (left &lt;= right)&#123; mid = (right + left) / 2; if (a[mid] == b) return 1; else if (a[mid] &gt; b)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; return -1; &#125;void array_insert(int a[], int lena, int b[], int lenb)&#123; //将所有在数组B中但不在A中的数据元素插入到A中 int cnt = 0; for (int i = 0; i &lt; lenb; i++) &#123; if (binarySearch(a, b[i], lena) == -1) &#123; a[lena + cnt] = b[i]; cnt++; &#125; &#125; lena += cnt; printf("A与B合并后的集合为：\n"); for (int i = 0; i &lt; lena; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main()&#123; arrayA_initialize(); arrayB_initialize(); array_insert(a, lena, b, lenb); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构实验四]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[问题描述对一个稀疏矩阵进行转置要求用十字链表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct OLNode&#123; int i, j; ElemType e; struct OLNode *right, *down;&#125;OLNode, *OLink;typedef struct CrossList&#123; OLink *rhead, *chead; int mu, nu, tu;&#125;CrossList, *pCrossList;void CreateSMatrix_OL(pCrossList M)&#123; //输入行数列数以及非零元个数 printf("请输入行数，列数，非零元素个数：\n"); scanf("%d%d%d", &amp;M-&gt;mu, &amp;M-&gt;nu, &amp;M-&gt;tu); if (M-&gt;tu * 20 &gt; M-&gt;mu * M-&gt;nu) printf("非稀疏矩阵，不建议使用此方法！\n"); //动态申请行和列指针数组 M-&gt;rhead = (OLink *)malloc(sizeof(OLink)*M-&gt;mu); if (M-&gt;rhead == NULL) return; M-&gt;chead = (OLink *)malloc(sizeof(OLink)*M-&gt;nu); if (M-&gt;chead == NULL)&#123; free(M-&gt;rhead); return; &#125; //初始化两个数组 int i, j; for (i = 1; i &lt;= M-&gt;mu; i++) M-&gt;rhead[i] = NULL; for (j = 1; j &lt;= M-&gt;nu; j++) M-&gt;chead[j] = NULL; //创建节点并连接到十字链表上 for (i = 1; i &lt;= M-&gt;tu; i++)&#123; OLink p = (OLink)malloc(sizeof(OLNode)); if (p == NULL) return; printf("请输入非零元素的行，列，值\n"); scanf("%d%d%d", &amp;p-&gt;i, &amp;p-&gt;j, &amp;p-&gt;e); p-&gt;down = NULL; p-&gt;right = NULL; //连接行 //如果该行并没有连接任何节点（NULL）或者该行连接的第一个节点的列值大于当前待连接的节点则直接将当前节点连接到该行第一个节点的位置 if (M-&gt;rhead[p-&gt;i] == NULL || M-&gt;rhead[p-&gt;i]-&gt;j &gt; p-&gt;j)&#123; p-&gt;right = M-&gt;rhead[p-&gt;i]; M-&gt;rhead[p-&gt;i] = p; &#125; //否则遍历该行找到合适的位置插入 else &#123; OLink q = M-&gt;rhead[p-&gt;i];//指向第一个节点，从第一个节点开始遍历 while (q-&gt;right != NULL &amp;&amp; q-&gt;right-&gt;j &lt; p-&gt;j)//遍历到前一个节点 q = q-&gt;right; p-&gt;right = q-&gt;right; q-&gt;right = p; &#125; //连接列 if (M-&gt;chead[p-&gt;j] == NULL || M-&gt;chead[p-&gt;j]-&gt;i &gt; p-&gt;i) &#123; p-&gt;down = M-&gt;chead[p-&gt;j]; M-&gt;chead[p-&gt;j] = p; &#125; else &#123; OLink pNodeTravel = M-&gt;chead[p-&gt;j]; while (pNodeTravel-&gt;down != NULL &amp;&amp; pNodeTravel-&gt;down-&gt;i &lt; p-&gt;i) pNodeTravel = pNodeTravel-&gt;down; p-&gt;down = pNodeTravel-&gt;down; pNodeTravel-&gt;down = p; &#125; &#125;&#125;void TransSMatrix_OL(CrossList M, CrossList *T)&#123; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; //Q的头节点的初始化 if (!(T-&gt;rhead = (OLink *)malloc((T-&gt;mu + 1) * sizeof(OLink)))) &#123;printf("内存空间申请失败！");return;&#125; if (!(T-&gt;chead = (OLink *)malloc((T-&gt;nu + 1) * sizeof(OLink)))) &#123; printf("内存空间申请失败！"); return; &#125; for (int i = 1; i &lt;= T-&gt;mu; i++) T-&gt;rhead[i] = NULL; for (int i = 1; i &lt;= T-&gt;nu; i++) T-&gt;chead[i] = NULL; if (!M.tu) return; OLink p, q, q_row, q_col; for (int i = 1; i &lt;= M.nu; i++)&#123; if (M.chead[i]) &#123; for (q = M.chead[i]; q;) &#123; if (!(p = (OLink)malloc(sizeof(OLNode))))&#123; printf("内存空间申请失败！"); return; &#125; p-&gt;i = q-&gt;j; p-&gt;j = q-&gt;i; p-&gt;e = q-&gt;e; p-&gt;right = p-&gt;down = NULL; q_row = T-&gt;rhead[i]; if (NULL == T-&gt;rhead[i]) T-&gt;rhead[i] = p; else &#123; while (q_row-&gt;right) q_row = q_row-&gt;right; q_row-&gt;right = p; &#125; q_col = T-&gt;chead[p-&gt;j]; if (T-&gt;chead[p-&gt;j] == NULL) T-&gt;chead[p-&gt;j] = p; else &#123; while (q_col-&gt;down) q_col = q_col-&gt;down; q_col-&gt;down = p; &#125; q = q-&gt;down; &#125; &#125; &#125; return;&#125;void OutputSMatrix_OL(pCrossList M, char s[])&#123; int i, j; OLink p; printf("----------------------\n"); printf("%s矩阵为：\n", s); for (i = 1; i &lt;= M-&gt;mu; i++)&#123; p = M-&gt;rhead[i]; for (j = 1; j &lt;= M-&gt;nu; j++)&#123; if (p != NULL &amp;&amp; p-&gt;j == j) &#123; printf("%d ", p-&gt;e); p = p-&gt;right; &#125; else printf("0 "); &#125; printf("\n"); &#125; printf("----------------------\n"); printf("\n"); return;&#125;int main()&#123; CrossList M, T; CreateSMatrix_OL(&amp;M); char s1[] = "原始"; OutputSMatrix_OL(&amp;M, s1); TransSMatrix_OL(M, &amp;T); char s2[] = "转置后"; OutputSMatrix_OL(&amp;T, s2); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验三]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[问题描述对一个对称矩阵进行压缩及解压缩注意 压缩时： 第一步：完整地显示矩阵 第二步： 完整地显示一维数组 ——————————————————————————————————————— 解压缩时： 第一步：完整地显示一维数组 第二步：完整地显示矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define Matrix_Num 5void input_Matrix(int *Matrix)&#123; printf("输入方阵：\n"); for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; scanf("%d", &amp;Matrix[Matrix_Num * i + j]); &#125; &#125; printf("\n"); return;&#125;void show1D(int Compressed[])&#123; for (int i = 0; i &lt; Matrix_Num*(Matrix_Num + 1) / 2; i++) printf("%d ", Compressed[i]); printf("\n"); return;&#125;void show2D(int Matrix[])&#123; for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; printf("%d ", Matrix[Matrix_Num*i + j]); &#125; printf("\n"); &#125; return;&#125;void compress(int Matrix[],int *Compressed)&#123; int n = 0; printf("您输入的方阵为：\n"); show2D(Matrix); printf("压缩后\n"); for (int i = 0; i &lt; Matrix_Num; i++) for (int j = 0; j &lt;= i; j++) Compressed[n++] = Matrix[Matrix_Num*i + j]; show1D(Compressed); printf("\n"); return;&#125;void uncompress_O1(int Compressed[],int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; int i, j; i = ceil(sqrt(2.25 + 2 * k) - 0.5); j = k - i * (i - 1) / 2; i--; Uncompressed[Matrix_Num*i + j] = Compressed[k]; Uncompressed[Matrix_Num*j + i] = Compressed[k]; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; int j = k - i * (i - 1) / 2 + 1; if (i &gt;= j &amp;&amp; j &gt;= 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; break; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On2(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (k == i * (i - 1) / 2 + j - 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; &#125; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;int main()&#123; int M[Matrix_Num * Matrix_Num]; int C[Matrix_Num * (Matrix_Num + 1) / 2]; int U[Matrix_Num * Matrix_Num]; input_Matrix(M); compress(M, C); uncompress_O1(C, U); //uncompress_On(C, U); //uncompress_On2(C, U); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验一]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !='' --2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001' --3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%' --4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc --5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号 --6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35 --7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001') --8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs --9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs --10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%' --12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20 --13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80 --14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业 --15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1) --16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5 --17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号 --19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别 --20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业 --21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/ --22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%' --23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号) select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号) --24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002') --25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1) --二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1' --2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno --3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200 --4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红') --5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400 --6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验二]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[问题描述1.第一次实验的顺序实现2.顺序栈的实现3.N个元素的序列的所有出栈可能1.第一次实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10#define ElemType int using namespace std;typedef struct &#123; ElemType *elem; int length; int listsize;&#125;SqList;void InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); L.length = 0; L.listsize = LIST_INIT_SIZE; return;&#125;int InputList_Sq(SqList &amp;L)&#123; ElemType n, temp; ElemType *p, *q; printf("请输入集合的元素个数：\n"); cin &gt;&gt; n; if (n &lt; 1 || n &gt; L.listsize) &#123; printf("输入有误\n"); return 0; &#125; if (L.length + n &gt;= L.listsize) &#123; L.elem = (ElemType*)realloc(L.elem, (L.length + n - L.listsize + LISTINCREMENT) * sizeof(ElemType)); L.listsize += (L.length + n - L.listsize + LISTINCREMENT); &#125; printf("请输入元素："); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q = &amp;(L.elem[i]); *q = temp; ++L.length; &#125; return 1;&#125;void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc)&#123; ElemType *pa, *pb, *pc, *pa_last, *pb_last; pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType*)malloc(Lc.listsize * sizeof(ElemType)); pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; if (*pa &lt; *pb) *pc++ = *pa++; else *pc++ = *pb++; &#125; while (pa &lt;= pa_last)*pc++ = *pa++; while (pb &lt;= pb_last)*pc++ = *pb++; return;&#125;void Show_Sq(SqList L, char name)&#123; int cnt = 0; printf("集合%c中的元素为：",name); for (int i = 0; i &lt; L.length; i++) &#123; if (L.elem[i] != L.elem[i + 1]) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; " "; cnt++; &#125; &#125; printf("去重后的元素个数为：%d\n", cnt); return;&#125;int main()&#123; SqList La, Lb, Lc; InitList_Sq(La); InitList_Sq(Lb); InitList_Sq(Lc); InputList_Sq(La); InputList_Sq(Lb); sort(La.elem, La.elem + La.length); sort(Lb.elem, Lb.elem + Lb.length); Show_Sq(La,'A'); Show_Sq(Lb,'B'); MergeList_Sq(La, Lb, Lc); Show_Sq(Lc,'C'); return 0;&#125; 2.顺序栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#define STACK_INIT_SIZE 100#define STACKINCREMENT 10#define SElemType intusing namespace std;typedef struct &#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return;&#125;int GetTop(SqStack S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *(S.top - 1); return 1;&#125;void Push(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top - S.base &gt;= S.stacksize) &#123; S.base = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return;&#125;int Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *--S.top; return 1;&#125;void Show(SqStack S)&#123; printf("栈中现有元素为： |"); for (auto it = S.base; it &lt; S.top; it++) cout &lt;&lt; *it &lt;&lt; " "; printf("\n"); return;&#125;int main()&#123; int p; SElemType x; SqStack S; InitStack(S); while (1) &#123; printf("请选择您要进行的操作(1代表Push 2代表Pop 0代表退出) ："); scanf("%d", &amp;p); if (p == 1) &#123; printf("请输入要压入栈中的元素："); cin &gt;&gt; x; Push(S, x); Show(S); &#125; else if (p == 2) &#123; SElemType e = 0; if (Pop(S, e)) &#123; printf("出栈元素为："); cout &lt;&lt; e &lt;&lt; endl; Show(S); &#125; else printf("栈中没有元素\n"); &#125; else &#123; Show(S); break; &#125; &#125; return 0;&#125; 3.所有出栈可能12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int total, res, sta, n;int r[2005], s[2005];void dfs(int m) &#123; if (m == n + 1) &#123; //若所有元素都入过栈，输出当前出栈序列 total++; for (int i = 1; i &lt;= res; i++) cout &lt;&lt; r[i] &lt;&lt; ' '; for (int i = sta; i &gt; 0; i--) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; if (sta &gt; 0) &#123; r[++res] = s[sta]; sta--; dfs(m); //栈顶元素出栈 s[++sta] = r[res]; res--; //回溯操作 &#125; s[++sta] = m; //当前元素入栈 dfs(m + 1); sta--; //回溯操作&#125;int main() &#123; printf("请输入元素个数："); scanf("%d", &amp;n); total = 0; res = 0; sta = 0; dfs(1); printf("共有%d种情况", total); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验一]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题描述1.算法2.12.分别用链式和顺序表实现3.所涉及的基本操作全部用函数实现链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cstring&gt; typedef struct LNode &#123; int data; LNode *next;&#125;LNode,*LinkList;void List_initialize(LinkList &amp;L, int n)&#123; LNode* p; L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i)&#123; p = (LNode *)malloc(sizeof(LNode)); scanf("%d", &amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;bool compare(int a, int b)&#123; if (a == b) return true;&#125;void List_show(LNode *head)&#123; LNode *p = head-&gt;next; while (p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;int GetElem(LNode *L, int pos)&#123; LNode *p = L-&gt;next; for (int i = 0; i &lt; pos - 1; i++) p = p-&gt;next; return p-&gt;data;&#125;int Listlen(LNode *head)&#123; LNode *p = head-&gt;next; int len = 0; while (p)&#123; len++; p = p-&gt;next; &#125; return len;&#125;int List_insert(LinkList &amp;L, int i, int e)&#123; if (i &lt; 1) return 0; LNode *p = L; LNode *s; int j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p) return 0; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return 1;&#125;LNode* List_only(LNode *head)&#123; LNode *p, *q, *s; p = head-&gt;next; while (p-&gt;next != NULL)&#123; q = p; while (q-&gt;next != NULL)&#123; if (q-&gt;next-&gt;data == p-&gt;data)&#123; s = q-&gt;next; q-&gt;next = s-&gt;next; free(s); &#125; else q = q-&gt;next; &#125; p = p-&gt;next; &#125; return head;&#125;void List_union(LinkList &amp;L1, LinkList L2)&#123; LinkList p, q, s; p = L1; q = L2; while (p-&gt;next != NULL) &#123; while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data == q-&gt;next-&gt;data) break; else q = q-&gt;next; &#125; if (q-&gt;next == NULL) &#123; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = p-&gt;next-&gt;data; s-&gt;next = NULL; q-&gt;next = s; &#125; p = p-&gt;next; q = L2; &#125;&#125;int main()&#123; int lena, lenb; LinkList la, lb; printf("请输入集合A的元素个数："); scanf("%d", &amp;lena); printf("请输入集合A元素："); List_initialize(la, lena); printf("原集合A："); List_show(la); printf("\n"); List_only(la); printf("集合去重后个数："); printf("%d",Listlen(la)); printf("\n"); printf("删除重复元素后的集合A为："); List_show(la); printf("\n"); printf("请输入集合B的元素个数："); scanf("%d", &amp;lenb); printf("请输入集合B元素："); List_initialize(lb, lenb); printf("集合B："); List_show(lb); printf("\n"); List_only(lb); printf("集合去重后个数："); printf("%d", Listlen(lb)); printf("\n"); printf("删除重复元素后的集合B为："); List_show(lb); printf("\n"); printf("A和B的并集为："); List_union(la, lb); List_only(la); List_show(la); return 0;&#125; 顺序表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000], b[10000];int lena, lenb;void arrayA_initialize()&#123; //输入集合A printf("请输入集合元素个数(小于10000)："); scanf("%d", &amp;lena); while (lena &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合A元素个数(小于10000)："); scanf("%d", &amp;lena); &#125; printf("请输入集合A元素："); int temp, cnta = 1; scanf("%d", &amp;a[0]); for (int i = 1; i &lt; lena; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == a[j]) flag = 0; &#125; if (flag) &#123; a[cnta] = temp; cnta++; &#125; &#125; lena = cnta; printf("数组A的长度最终为： %d\n", lena); printf("去重后的数组A为 ：\n"); for (int i = 0; i &lt; lena; i++) printf("%d ", a[i]); printf("\n");&#125;void arrayB_initialize()&#123; //输入集合B printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); while (lenb &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); &#125; printf("请输入集合B元素："); int temp, cntb = 1; scanf("%d", &amp;b[0]); for (int i = 1; i &lt; lenb; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == b[j]) flag = 0; &#125; if (flag) &#123; b[cntb] = temp; cntb++; &#125; &#125; lenb = cntb; printf("数组B的长度最终为： %d\n", lenb); printf("去重后的数组B为 ：\n"); for (int i = 0; i &lt; lenb; i++) printf("%d ", b[i]); printf("\n");&#125;int binarySearch(int a[], int b, int lena) &#123; int left = 0, right = lena - 1, mid; while (left &lt;= right)&#123; mid = (right + left) / 2; if (a[mid] == b) return 1; else if (a[mid] &gt; b)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; return -1; &#125;void array_insert(int a[], int lena, int b[], int lenb)&#123; //将所有在数组B中但不在A中的数据元素插入到A中 int cnt = 0; for (int i = 0; i &lt; lenb; i++) &#123; if (binarySearch(a, b[i], lena) == -1) &#123; a[lena + cnt] = b[i]; cnt++; &#125; &#125; lena += cnt; printf("A与B合并后的集合为：\n"); for (int i = 0; i &lt; lena; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main()&#123; arrayA_initialize(); arrayB_initialize(); array_insert(a, lena, b, lenb); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
</search>

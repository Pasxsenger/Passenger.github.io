<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构实验一]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题描述1.算法2.12.分别用链式和顺序表实现3.所涉及的基本操作全部用函数实现链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cstring&gt; typedef struct LNode &#123; int data; LNode *next;&#125;LNode,*LinkList;void List_initialize(LinkList &amp;L, int n)&#123; LNode* p; L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i)&#123; p = (LNode *)malloc(sizeof(LNode)); scanf("%d", &amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;bool compare(int a, int b)&#123; if (a == b) return true;&#125;void List_show(LNode *head)&#123; LNode *p = head-&gt;next; while (p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;int GetElem(LNode *L, int pos)&#123; LNode *p = L-&gt;next; for (int i = 0; i &lt; pos - 1; i++) p = p-&gt;next; return p-&gt;data;&#125;int Listlen(LNode *head)&#123; LNode *p = head-&gt;next; int len = 0; while (p)&#123; len++; p = p-&gt;next; &#125; return len;&#125;int List_insert(LinkList &amp;L, int i, int e)&#123; if (i &lt; 1) return 0; LNode *p = L; LNode *s; int j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p) return 0; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return 1;&#125;LNode* List_only(LNode *head)&#123; LNode *p, *q, *s; p = head-&gt;next; while (p-&gt;next != NULL)&#123; q = p; while (q-&gt;next != NULL)&#123; if (q-&gt;next-&gt;data == p-&gt;data)&#123; s = q-&gt;next; q-&gt;next = s-&gt;next; free(s); &#125; else q = q-&gt;next; &#125; p = p-&gt;next; &#125; return head;&#125;void List_union(LinkList &amp;L1, LinkList L2)&#123; LinkList p, q, s; p = L1; q = L2; while (p-&gt;next != NULL) &#123; while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data == q-&gt;next-&gt;data) break; else q = q-&gt;next; &#125; if (q-&gt;next == NULL) &#123; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = p-&gt;next-&gt;data; s-&gt;next = NULL; q-&gt;next = s; &#125; p = p-&gt;next; q = L2; &#125;&#125;int main()&#123; int lena, lenb; LinkList la, lb; printf("请输入集合A的元素个数："); scanf("%d", &amp;lena); printf("请输入集合A元素："); List_initialize(la, lena); printf("原集合A："); List_show(la); printf("\n"); List_only(la); printf("集合去重后个数："); printf("%d",Listlen(la)); printf("\n"); printf("删除重复元素后的集合A为："); List_show(la); printf("\n"); printf("请输入集合B的元素个数："); scanf("%d", &amp;lenb); printf("请输入集合B元素："); List_initialize(lb, lenb); printf("集合B："); List_show(lb); printf("\n"); List_only(lb); printf("集合去重后个数："); printf("%d", Listlen(lb)); printf("\n"); printf("删除重复元素后的集合B为："); List_show(lb); printf("\n"); printf("A和B的并集为："); List_union(la, lb); List_only(la); List_show(la); return 0;&#125; 顺序表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000], b[10000];int lena, lenb;void arrayA_initialize()&#123; //输入集合A printf("请输入集合元素个数(小于10000)："); scanf("%d", &amp;lena); while (lena &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合A元素个数(小于10000)："); scanf("%d", &amp;lena); &#125; printf("请输入集合A元素："); int temp, cnta = 1; scanf("%d", &amp;a[0]); for (int i = 1; i &lt; lena; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == a[j]) flag = 0; &#125; if (flag) &#123; a[cnta] = temp; cnta++; &#125; &#125; lena = cnta; printf("数组A的长度最终为： %d\n", lena); printf("去重后的数组A为 ：\n"); for (int i = 0; i &lt; lena; i++) printf("%d ", a[i]); printf("\n");&#125;void arrayB_initialize()&#123; //输入集合B printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); while (lenb &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); &#125; printf("请输入集合B元素："); int temp, cntb = 1; scanf("%d", &amp;b[0]); for (int i = 1; i &lt; lenb; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == b[j]) flag = 0; &#125; if (flag) &#123; b[cntb] = temp; cntb++; &#125; &#125; lenb = cntb; printf("数组B的长度最终为： %d\n", lenb); printf("去重后的数组B为 ：\n"); for (int i = 0; i &lt; lenb; i++) printf("%d ", b[i]); printf("\n");&#125;int binarySearch(int a[], int b, int lena) &#123; int left = 0, right = lena - 1, mid; while (left &lt;= right)&#123; mid = (right + left) / 2; if (a[mid] == b) return 1; else if (a[mid] &gt; b)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; return -1; &#125;void array_insert(int a[], int lena, int b[], int lenb)&#123; //将所有在数组B中但不在A中的数据元素插入到A中 int cnt = 0; for (int i = 0; i &lt; lenb; i++) &#123; if (binarySearch(a, b[i], lena) == -1) &#123; a[lena + cnt] = b[i]; cnt++; &#125; &#125; lena += cnt; printf("A与B合并后的集合为：\n"); for (int i = 0; i &lt; lena; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main()&#123; arrayA_initialize(); arrayB_initialize(); array_insert(a, lena, b, lenb); return 0;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F09%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Daily</category>
      </categories>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据结构课程设计实验三]]></title>
    <url>%2F2020%2F03%2F13%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[题目单词检索统计程序 项目简介给定一个文本文件（见文后注意事项），要求统计给定单词在文本中出现的总次数，并检索输出某个单词出现在文本中的行号、在该行中出现的次数以及位置。 功能描述使用者可创建自己命名的.txt文件，并写入其内容；还可以输入搜索的词并查找其出现次数、行号和所在的句子。 代码清单1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import reimport sysfrom string import punctuationdef create_file(name, msg): partial_path = "D:\\Program Files (x86)\\JetBrains\\PyCharm 2019.2.4\\MyCode\\date_structure\\" full_path = partial_path + name + '.txt' global full_name full_name = full_path file = open(full_path, 'w') file.write(msg) print("File created successfully\n") print(full_name)def run_query(wanted): word_total = 0 for each in one_word_list: if each == wanted: word_total += 1 print('"&#123;&#125;" occurs &#123;&#125; times'.format(wanted, word_total)) line_number = 0 for line in text_list: line_plain = re.sub(r'[&#123;&#125;]'.format(punctuation), '', line) word_list = [word.lower() for word in line_plain.split()] line_number += 1 if wanted in word_list: print('\tline &#123;&#125;: &#123;&#125;'.format(line_number, text_list[line_number - 1]), end='')if __name__ == '__main__': while True: print("1.create file\n2.count and locate\n3.quit\n") choice = input("Please enter the choice number:\n") if choice == "1": name = input("Please enter the name of file:\n") msg = input("Please enter the contents:\n") create_file(name, msg) elif choice == "2": wanted = input("Please enter the word:\n") text = open(full_name, 'r') text_list = text.readlines() text_plain = re.sub(r'[&#123;&#125;]'.format(punctuation), '', ''.join(text_list)) one_word_list = [word.lower() for word in text_plain.split()] print(one_word_list) run_query(wanted) print("\n") else: print("Thanks for using!\nBye~") sys.exit(0)]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构课程设计实验二]]></title>
    <url>%2F2020%2F03%2F08%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[题目银行排队系统 项目简介大家肯定都曾经去银行办过业务，例如我们东门口的中国银行山大分行。银行排队采用的是链式队列，逻辑上相邻，物理上可以不相邻。本次实验要求大家做一个“快应用”，功能上只需要实现队列的FIFO即可 很多同学是第一次开发快应用，因为时间原因，我们这次对物理结构不做要求（链式，顺序）均可。安卓手机请先安装一个快应用调试器，用调试器打开rpk安装包进入快应用，非安卓手机的同学请安装模拟器。17级的徐莫迟同学作为本次作业的技术顾问，专门写了一份文档，内容详实，请参考http://xmcblog.com/2020/02/27/。 功能描述到银行办理业务的顾客通过快应用扫码向服务器发送入队请求并入队，同时后端定时弹出队头。用户可通过点击屏幕按钮查询自己在队伍中的位置。 代码清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113（1）index.ux&lt;template&gt; &lt;div class="demo-page"&gt; &lt;text class="title"&gt;欢迎使用&lt;/text&gt; &lt;!-- 点击跳转详情页 --&gt; &lt;input class="btn" type="button" value="扫码排队" onclick="scanQR" /&gt; &lt;input class="btn" type="button" value="查询位置" onclick="query" /&gt; &lt;img class = "image" src = "https://s2.ax1x.com/2020/03/08/3zJfSJ.jpg"&gt;&lt;/img&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import router from '@system.router'import prompt from '@system.prompt'import barcode from '@system.barcode'import device from '@system.device'import fetch from '@system.fetch'export default &#123; private: &#123; id:'', url:'', &#125;, onInit() &#123; const self = this device.getUserId(&#123; success: (data) =&gt; &#123; self.id = data.userId prompt.showToast(&#123; message: 'ID got' &#125;) &#125; &#125;) &#125;, scanQR()&#123; const self = this barcode.scan(&#123; success: (data) =&gt; &#123; self.url = data.result fetch.fetch(&#123; url: self.url + '1', data: &#123;"id": self.id&#125;, method: 'GET', responseType: 'text', success: (response) =&gt; &#123; prompt.showToast(&#123; message: response.data &#125;) &#125;, fail: (data, code) =&gt; &#123; prompt.showToast(&#123; message: '排队失败请检查网络' &#125;) &#125; &#125;) &#125;, fail: (data, code) =&gt; &#123; prompt.showToast(&#123; message: '获取相机权限失败' &#125;) &#125; &#125;) &#125;, query() &#123; const self = this fetch.fetch(&#123; url: self.url + '2', data: &#123;'id': self.id&#125;, method: 'GET', responseType: 'text', success: (response) =&gt; &#123; prompt.showToast(&#123; message: response.data &#125;) &#125;, fail: (data, code) =&gt; &#123; prompt.showToast(&#123; message: '查询失败请先扫码' &#125;) &#125; &#125;) &#125;&#125;&lt;/script&gt;&lt;style&gt; .demo-page &#123; flex-direction: column; justify-content: center; align-items: center; &#125; .title &#123; font-size: 40px; text-align: center; &#125; .image &#123; border-radius: 8px; &#125; .btn &#123; width: 550px; height: 86px; margin-top: 75px; border-radius: 43px; background-color: #09ba07; font-size: 30px; color: #ffffff; &#125;&lt;/style&gt; 12345678910111213141516171819202122232425262728293031323334353637383940from flask import Flaskfrom flask import requestimport timeimport threadingapp = Flask(__name__)q = []@app.route('/1', methods=['POST', 'GET'])def index1(): id = request.args.get('id') if q.count(id): return '当前已在队列中' else: q.append(id) return '排队成功'@app.route('/2', methods=['POST', 'GET'])def index2(): id = request.args.get('id') if q.count(id): return '您当前所排的位置是' + str(q.index(id) + 1) else: return '您当前不在队列中'def popque(): while True: time.sleep(10) if q: q.pop(0)if __name__ == "__main__": t = threading.Thread(target=popque) t.start() app.run(debug=True, host='192.168.31.120') t.join()]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构课程设计实验一]]></title>
    <url>%2F2020%2F02%2F25%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[题目考试报名管理系统 项目简介​ 考试报名给各高校报名工作带来了新的挑战，给教务管理部门增加了很大的工作量，报名数据手工录入既费时又会不可避免地出现错误。本项目是对考试报名管理的简单模拟，请用菜单选择方式完成下列功能：输入考生信息；输出考生信息；查询考生信息；添加考生信息；修改考生信息；删除考生信息。 功能描述 打开功能：可在用户界面从.txt文件中的信息显示到表格中。 显示功能：完成全部记录的显示。 查找功能：完成按姓名查找学生信息功能并显示，可分为精确查询和模糊查询。 排序功能：按录入的准考证号依次排序显示。 编辑功能：对指定的学生的信息进行编辑，更改ArrayList中的值。 删除功能：选中学生，将其从ArrayList中删除。 保存功能：将查询到的学生信息保存在选择目录的.txt文件下。 代码清单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469//（1） GUIpackage data_structure;import java.awt.*;import java.util.Vector;import java.awt.event.*;import javax.swing.*;import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;import java.io.*;import javax.swing.table.DefaultTableModel;import javax.swing.table.JTableHeader;public class GUI extends JFrame implements ActionListener&#123; private JTable jtb; private DefaultComboBoxModel&lt;String&gt; combo; private JTextField jtf; private DefaultTableModel table; private ArrayList&lt;Management&gt; stu; private JFileChooser jfc; private Comparator&lt;Management&gt; cmp; public GUI()&#123; super("考试报名管理系统"); this.setBounds(350, 150, 1200, 700); this.setDefaultCloseOperation(EXIT_ON_CLOSE); this.setLayout(null); this.jfc = new JFileChooser(); this.jfc.setFileFilter(new Filter("文本文件(*.txt)","txt")); //顶部菜单栏 JMenuBar jmb = new JMenuBar(); JMenu jm = new JMenu("文件"); JMenuItem jm1 = new JMenuItem("保存"); jm1.addActionListener(this); JMenuItem jm2 = new JMenuItem("打开"); jm2.addActionListener(this); jm.add(jm1); jm.add(jm2); jmb.add(jm); jmb.setBounds(0,0,1200,30); this.add(jmb); //按钮面板 JPanel jp = new JPanel(); //下拉列表 combo = new DefaultComboBoxModel&lt;String&gt;(); JComboBox&lt;String&gt; jcb = new JComboBox&lt;String&gt;(combo); combo.addElement("模糊查询"); combo.addElement("精确查询"); jcb.setFont(new Font("宋体",Font.PLAIN,20)); jp.add(jcb); //标签 JLabel jl = new JLabel("输入学生姓名"); jl.setFont(new Font("宋体",Font.PLAIN,20)); jp.add(jl); //输入框 jtf = new JTextField("",20); jtf.setFont(new Font("宋体",Font.PLAIN,20)); jp.add(jtf); //按钮 String[] buttonNames = &#123;"查询", "编辑", "添加", "删除"&#125;; for(int i = 0; i &lt; buttonNames.length; i++) &#123; JButton jb = new JButton(buttonNames[i]); jb.setFont(new Font("宋体",Font.PLAIN,20)); jb.addActionListener(this); jp.add(jb); &#125; jp.setBounds(0,30,1200,50); this.add(jp); //显示信息的表格 Vector&lt;String&gt; column = new Vector&lt;String&gt;(); String[] columnNames = &#123;"准考证号", "姓名", "性别", "年龄", "成绩"&#125;; for(int i = 0; i &lt; columnNames.length; i++) column.add(columnNames[i]); table = new DefaultTableModel(column, 0); jtb = new JTable(table); JScrollPane jsp = new JScrollPane(jtb); jtb.setRowHeight(30);//设置表格行宽 jtb.setFont(new Font("宋体",Font.PLAIN,25));//设置表格字体 JTableHeader head = jtb.getTableHeader(); head.setPreferredSize(new Dimension(head.getWidth(),40));//设置表头大小 head.setFont(new Font("微软雅黑",Font.PLAIN,25));//设置表头字体 jtb.setBounds(10,120,1160,500); jsp.setBounds(10,100,1160,500); this.add(jsp); //排序 cmp = Comparator.comparingInt(m -&gt; Integer.valueOf(m.examno)); stu = new ArrayList&lt;Management&gt;(); this.setVisible(true);//设为可见 &#125; //把stu中的信息显示到表格里 public static void showStu(DefaultTableModel table, ArrayList&lt;Management&gt; stu) &#123; for(Management m:stu) &#123; String[] info = new String[]&#123;m.examno, m.name, m.sex, String.valueOf(m.age), String.valueOf(m.grade)&#125;; table.addRow(info); &#125; &#125; public void actionPerformed(ActionEvent e) &#123; switch(e.getActionCommand()) &#123; case "查询": switch(combo.getSelectedItem().toString()) &#123; case "模糊查询": table.setRowCount(0); String inputF = jtf.getText().trim(); for(Management m: stu) &#123; if(m.name.contains(inputF)) &#123; String[]info = new String[]&#123;m.examno, m.name, m.sex, String.valueOf(m.age), String.valueOf(m.grade)&#125;; table.addRow(info); &#125; &#125; break; case "精确查询": table.setRowCount(0); String inputA = jtf.getText().trim(); for(Management m: stu) &#123; if(m.name.equals(inputA)) &#123; String[]info = new String[]&#123;m.examno, m.name, m.sex, String.valueOf(m.age), String.valueOf(m.grade)&#125;; table.addRow(info); &#125; &#125; break; &#125; break; case "编辑": new EditFrame(table, stu, jtb); break; case "添加": new AddFrame(table, stu); break; case "删除": int row = jtb.getSelectedRow();//获取要删除的行号 stu.remove(row);//删除所选行// refresh(table, stu); table.setRowCount(0); Collections.sort(stu, cmp); showStu(table,stu);//重新打开 break; case "保存": if(jfc.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) &#123; Filter filter = (Filter) jfc.getFileFilter(); String ends = filter.getExt(); File newFile= new File(jfc.getSelectedFile().getAbsolutePath() + '.' + ends); if (!newFile.exists()) &#123; try &#123; newFile.createNewFile(); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; &#125; IO.writeTo(newFile, stu); &#125; break; case "打开": if(jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) &#123; File file = jfc.getSelectedFile(); stu.clear(); IO.readFrom(file, stu); table.setRowCount(0); showStu(table, stu); &#125; break; &#125; &#125; public static void main(String[] args) &#123; new GUI(); &#125;&#125;//（2） EditFramepackage data_structure;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.util.ArrayList;import java.util.Comparator;import javax.swing.*;import javax.swing.table.DefaultTableModel;public class EditFrame extends JFrame implements ActionListener &#123; private JTextField[] jtf; private ArrayList&lt;Management&gt; stu; private DefaultTableModel table; private int notNull = 1; private Comparator&lt;Management&gt; cmp; private int row; EditFrame(DefaultTableModel table, ArrayList&lt;Management&gt; stu, JTable jtb) &#123; super("Edit Student"); this.stu = stu; this.table = table; this.setBounds(700, 260, 500, 480); this.setLayout(new GridLayout(6, 1)); cmp = Comparator.comparingInt(s -&gt; Integer.parseInt(s.examno)); JPanel[] jp = new JPanel[6]; for (int i = 0; i &lt; jp.length; i++) &#123; jp[i] = new JPanel(); &#125; jtf = new JTextField[5]; for (int i = 0; i &lt; jtf.length; i++) &#123; jtf[i] = new JTextField("", 10); jtf[i].setFont(new Font("宋体",Font.PLAIN,20)); String[] columnNames = &#123;"准考证号", "姓名", "性别", "年龄", "成绩"&#125;; JLabel jlb = new JLabel(columnNames[i]); jlb.setFont(new Font("宋体",Font.PLAIN,20)); jp[i].add(jlb); jp[i].add(jtf[i]); &#125; row = jtb.getSelectedRow(); jtf[0].setText(stu.get(row).examno); jtf[1].setText(stu.get(row).name); jtf[2].setText(stu.get(row).sex); jtf[3].setText(String.valueOf(stu.get(row).age)); jtf[4].setText(String.valueOf(stu.get(row).grade)); String[] buttonNames = &#123;"确认", "取消"&#125;; for (String buttonName : buttonNames) &#123; JButton button = new JButton(buttonName); button.setFont(new Font("宋体", Font.PLAIN, 20)); button.addActionListener(this); jp[5].add(button); &#125; for (JPanel jPanel : jp) this.add(jPanel); this.setVisible(true); &#125; public void actionPerformed(ActionEvent e) &#123; switch (e.getActionCommand()) &#123; case "确认": stu.remove(row); for (JTextField jTextField : jtf) if (jTextField.getText().isEmpty()) &#123; JOptionPane.showMessageDialog(this, "添加学生信息不能为空"); notNull = 0; this.setVisible(false); break; &#125; if (notNull == 1) &#123; Management newstu = new Management(jtf[0].getText(), jtf[1].getText(), jtf[2].getText(), Integer.parseInt(jtf[3].getText().trim()), Double.parseDouble(jtf[4].getText().trim())); stu.add(newstu); stu.sort(cmp); table.setRowCount(0); GUI.showStu(table, stu); this.setVisible(false); &#125; break; case "取消": this.setVisible(false); break; &#125; &#125;&#125;//（3） AddFramepackage data_structure;import java.awt.*;import java.awt.event.*;import javax.swing.*;import javax.swing.table.DefaultTableModel;import java.util.ArrayList;import java.util.Comparator;public class AddFrame extends JFrame implements ActionListener&#123; private JTextField[] jtf; private ArrayList&lt;Management&gt; stu; private DefaultTableModel table; private int notNull = 1; private Comparator&lt;Management&gt; cmp; AddFrame(DefaultTableModel table, ArrayList&lt;Management&gt; stu) &#123; super("添加学生信息"); this.stu = stu; this.table = table; this.setBounds(700, 260, 500, 480); this.setLayout(new GridLayout(6,1)); cmp = Comparator.comparingInt(s -&gt; Integer.parseInt(s.examno)); JPanel[] jp = new JPanel[6]; for(int i = 0; i &lt; jp.length; i++) &#123; jp[i] = new JPanel(); &#125; jtf = new JTextField[5]; for(int i = 0; i &lt; jtf.length; i++) &#123; JTextField jtfAdd = new JTextField("", 10); jtfAdd.setFont(new Font("宋体",Font.PLAIN,20)); jtf[i] = jtfAdd; String[] columnNames = &#123;"准考证号", "姓名", "性别", "年龄", "成绩"&#125;; JLabel jl = new JLabel(columnNames[i]); jl.setFont(new Font("宋体",Font.PLAIN,20)); jp[i].add(jl); jp[i].add(jtf[i]); &#125; String[] buttonNames = &#123;"确认", "取消"&#125;; for (String buttonName : buttonNames) &#123; JButton button = new JButton(buttonName); button.setFont(new Font("宋体", Font.PLAIN, 20)); button.addActionListener(this); jp[5].add(button); &#125; for (JPanel jPanel : jp) this.add(jPanel); this.setVisible(true); &#125; public void actionPerformed(ActionEvent e) &#123; switch(e.getActionCommand()) &#123; case "确认": for (JTextField jTextField : jtf) if (jTextField.getText().isEmpty()) &#123; JOptionPane.showMessageDialog(this, "添加学生信息不能为空"); notNull = 0; this.setVisible(false); break; &#125; if(notNull == 1) &#123; Management newstu = new Management(jtf[0].getText(), jtf[1].getText(), jtf[2].getText(), Integer.parseInt(jtf[3].getText().trim()),Double.parseDouble(jtf[4].getText().trim())); stu.add(newstu); stu.sort(cmp); table.setRowCount(0); GUI.showStu(table, stu); this.setVisible(false); &#125; break; case "取消": dispose(); break; &#125; &#125;&#125;//（4） Filterpackage data_structure;import java.io.File;public class Filter extends javax.swing.filechooser.FileFilter &#123; private String desc, ext; Filter(String description, String extension) &#123; this.desc = description; this.ext = extension.toLowerCase(); &#125; public boolean accept(File file) &#123; return file.getName().toLowerCase().endsWith(this.ext); &#125; public String getDescription() &#123; return this.desc; &#125; String getExt() &#123; return this.ext; &#125;&#125;//（5） IOpackage data_structure;import java.io.*;import java.nio.charset.StandardCharsets;import java.util.ArrayList;import javax.swing.JOptionPane;class IO &#123; static void readFrom(File file, ArrayList&lt;Management&gt; arr) &#123; try &#123; BufferedReader bfr = new BufferedReader(new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8)); String line; while((line=bfr.readLine())!=null) &#123; String[]keys = line.split(";"); Management a = new Management(keys[0],keys[1],keys[2],Integer.parseInt(keys[3]),Double.parseDouble(keys[4])); arr.add(a); &#125; bfr.close(); &#125; catch(FileNotFoundException ex) &#123; if(!file.getName().equals("")) JOptionPane.showMessageDialog(null, "\""+file.getName()+"\"文件不存在。"); &#125; catch(IOException ex) &#123; JOptionPane.showMessageDialog(null, "读取文件时数据错误"); &#125; &#125; static void writeTo(File file, ArrayList&lt;Management&gt; arr) &#123; try &#123; BufferedWriter bufrd = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file, false), "UTF-8")); String line = new String(""); for(Management s:arr) &#123; line = s.toString(); bufrd.write(line + "\r\n"); &#125; bufrd.close(); &#125; catch(FileNotFoundException ex) &#123; if (!file.getName().equals("")) JOptionPane.showMessageDialog(null, "\"" + file.getName() + "\"文件不存在。"); &#125; catch(IOException ex) &#123; JOptionPane.showMessageDialog(null, "写入文件时数据错误"); &#125; &#125;&#125;//（6） Managementpackage data_structure;public class Management &#123; String examno; //准考证号 String name; //姓名 String sex; //性别 int age; //年龄 double grade; //成绩 //无参构造方法 public Management() &#123; super(); &#125; //有参构造方法 Management(String examno, String name, String sex, int age, double grade) &#123; super(); this.examno = examno; this.name = name; this.sex = sex; this.age = age; this.grade = grade; &#125; public String toString()&#123; return this.examno + ";" + this.name + ";" + this.sex + ";" + String.valueOf(this.age) + ";" + String.valueOf(this.grade) ; &#125;&#125;]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA算法与数据结构 7-9 旅游规划]]></title>
    <url>%2F2019%2F12%2F16%2FPTA%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-9-%E6%97%85%E6%B8%B8%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[有了一张自驾旅游路线图，你会知道城市间的高速公路长度、以及该公路要收取的过路费。现在需要你写一个程序，帮助前来咨询的游客找一条出发地和目的地之间的最短路径。如果有若干条路径都是最短的，那么需要输出最便宜的一条路径。 输入格式:输入说明：输入数据的第1行给出4个正整数N、M、S、D，其中N（2≤N≤500）是城市的个数，顺便假设城市的编号为0~(N−1)；M是高速公路的条数；S是出发地的城市编号；D是目的地的城市编号。随后的M行中，每行给出一条高速公路的信息，分别是：城市1、城市2、高速公路长度、收费额，中间用空格分开，数字均为整数且不超过500。输入保证解的存在。 输出格式:在一行里输出路径的长度和收费总额，数字间以空格分隔，输出结尾不能有多余空格。 输入样例:1234564 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20 输出样例:13 40 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;using namespace std;const int Inf = 999999;int map[505][505], expense[505][505];int dis[505], exps[505];int vis[505] = &#123; 0 &#125;;int n, m, s, d;void Dijkstra()&#123; int min, rec; vis[s] = 1; while (1) &#123; min = Inf; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; dis[i] &lt; min) &#123; rec = i; min = dis[i]; &#125; &#125; if (min == Inf) break; vis[rec] = 1; for (int i = 0; i &lt; n; i++) &#123; if (!vis[i] &amp;&amp; map[rec][i] + dis[rec] &lt;= dis[i]) &#123; if (map[rec][i] + dis[rec] &lt; dis[i]) &#123; dis[i] = map[rec][i] + dis[rec]; exps[i] = expense[rec][i] + exps[rec]; &#125; else if (expense[rec][i] + exps[rec] &lt; exps[i]) exps[i] = expense[rec][i] + exps[rec]; &#125; &#125; &#125; return;&#125;int main()&#123; scanf("%d%d%d%d", &amp;n, &amp;m, &amp;s, &amp;d); memset(dis, Inf, sizeof(dis)); memset(exps, Inf, sizeof(exps)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (i == j) &#123; map[i][j] = 0; expense[i][j] = 0; &#125; else &#123; map[i][j] = Inf; expense[i][j] = Inf; &#125; &#125; &#125; int u, v, len, fee; for (int i = 0; i &lt; m; i++) &#123; scanf("%d%d%d%d", &amp;u, &amp;v, &amp;len, &amp;fee); map[u][v] = len; map[v][u] = len; expense[u][v] = fee; expense[v][u] = fee; &#125; dis[s] = 0; exps[s] = 0; for (int i = 0; i &lt; n; i++) &#123; if (map[s][i] != Inf) &#123; dis[i] = map[s][i]; exps[i] = expense[s][i]; &#125; &#125; Dijkstra(); printf("%d %d", dis[d], exps[d]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA算法与数据结构 7-8 哈利·波特的考试]]></title>
    <url>%2F2019%2F12%2F13%2FPTA%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-7-8-%E5%93%88%E5%88%A9%C2%B7%E6%B3%A2%E7%89%B9%E7%9A%84%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[哈利·波特要考试了，他需要你的帮助。这门课学的是用魔咒将一种动物变成另一种动物的本事。例如将猫变成老鼠的魔咒是haha，将老鼠变成鱼的魔咒是hehe等等。反方向变化的魔咒就是简单地将原来的魔咒倒过来念，例如ahah可以将老鼠变成猫。另外，如果想把猫变成鱼，可以通过念一个直接魔咒lalala，也可以将猫变老鼠、老鼠变鱼的魔咒连起来念：hahahehe。 现在哈利·波特的手里有一本教材，里面列出了所有的变形魔咒和能变的动物。老师允许他自己带一只动物去考场，要考察他把这只动物变成任意一只指定动物的本事。于是他来问你：带什么动物去可以让最难变的那种动物（即该动物变为哈利·波特自己带去的动物所需要的魔咒最长）需要的魔咒最短？例如：如果只有猫、鼠、鱼，则显然哈利·波特应该带鼠去，因为鼠变成另外两种动物都只需要念4个字符；而如果带猫去，则至少需要念6个字符才能把猫变成鱼；同理，带鱼去也不是最好的选择。 输入格式:输入说明：输入第1行给出两个正整数N (≤100)和M，其中N是考试涉及的动物总数，M是用于直接变形的魔咒条数。为简单起见，我们将动物按1~N编号。随后M行，每行给出了3个正整数，分别是两种动物的编号、以及它们之间变形需要的魔咒的长度(≤100)，数字之间用空格分隔。 输出格式:输出哈利·波特应该带去考场的动物的编号、以及最长的变形魔咒的长度，中间以空格分隔。如果只带1只动物是不可能完成所有变形要求的，则输出0。如果有若干只动物都可以备选，则输出编号最小的那只。 输入样例:1234567891011126 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80 输出样例:14 70 题解：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#define Inf 999using namespace std;int spell[105][105]; //开始为1的邻接矩阵，记录对应的咒语长度int len[105][105]; //开始为1的邻接矩阵，记录对应的最短咒语长度，每行的0号位置记录该行最长的魔咒长度int vis[105];int n, m;void Dijkstra(int u)&#123; vis[u] = 1; len[u][u] = 0; for (int i = 2; i &lt;= n; i++) &#123; int min = Inf, minp; for (int j = 1; j &lt;= n; j++) &#123; if (!vis[j] &amp;&amp; len[u][j] &lt; min) &#123; min = len[u][j]; minp = j; &#125; &#125; vis[minp] = 1; for (int j = 1; j &lt;= n; j++) &#123; if (len[u][j] &gt; min + spell[minp][j]) len[u][j] = min + spell[minp][j]; &#125; &#125; return;&#125;int main()&#123; scanf("%d%d", &amp;n, &amp;m); for (int i = 0; i &lt;= n; i++) &#123; for (int j = 0; j &lt;= n; j++) &#123; spell[i][j] = Inf; len[i][j] = Inf; &#125; spell[i][i] = 0; len[i][i] = 0; &#125; int u, v, w; //记录所有魔咒 for (int i = 1; i &lt;= m; i++) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;w); spell[u][v] = w; spell[v][u] = w; len[u][v] = w; len[v][u] = w; &#125; for (int i = 1; i &lt;= n; i++) &#123; //以每一个点都作为源点，求到其余各点的最短咒语 memset(vis, 0, sizeof(vis)); Dijkstra(i); len[i][0] = 0; //把该行最长的咒语放到第0位 for (int j = 1; j &lt;= n; j++) &#123; if (len[i][0] &lt; len[i][j]) len[i][0] = len[i][j]; &#125; &#125; int res = 0; len[0][0] = Inf; for (int i = 1; i &lt;= n; i++) &#123; if (len[i][0] &gt; 0 &amp;&amp; len[i][0] &lt; len[res][0]) res = i; &#125; if (res == 0) printf("0"); else printf("%d %d", res, len[res][0]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA算法与数据结构 6-1 单链表逆转]]></title>
    <url>%2F2019%2F12%2F12%2FPTA%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-6-1-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[本题要求实现一个函数，将给定的单链表逆转。 函数接口定义：1List Reverse( List L ); 其中List结构定义如下： 123456typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */ L是给定单链表，函数Reverse要返回被逆转后的链表。 裁判测试程序样例：123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read(); /* 细节在此不表 */void Print( List L ); /* 细节在此不表 */List Reverse( List L );int main()&#123; List L1, L2; L1 = Read(); L2 = Reverse(L1); Print(L1); Print(L2); return 0;&#125;/* 你的代码将被嵌在这里 */ 输入样例：1251 3 4 5 2 输出样例：1212 5 4 3 1 题解：12345678910111213List Reverse(List L)&#123; List R = NULL; PtrToNode p, q; p = L; while (p) &#123; q = p; p = p-&gt;Next; q-&gt;Next = R; R = q; &#125; return R;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOEFL-Writing-Living and Thinking]]></title>
    <url>%2F2019%2F11%2F24%2FTOEFL-Writing-Living-and-Thinking%2F</url>
    <content type="text"><![CDATA[Expressions: 相应的 correspondingly 一代代 generation after generation 老一辈 older generation 无法想象 than one could imagine 多才多艺的 versatile 忙于，投身于 be engaged in 尖端科技 cutting-edge technology 提高竞争力 sharpen/strengthen one’s competitive edge/advantage 精通于 be proficient in / expert in / excel at 流行 prevalence/popularity be all the rage 喧嚣 hustle and bustle 勉强，不愿意 be reluctant to 首要任务 top priority 金钱赔偿 financial compensation 愤怒 at rage 流传，传递 sth pass on from sb to sb 叛逆的 rebellious 青春期 puberty 扭曲的价值观 twisted value 高调的 high-profile 低调的 low-key 受……影响，制约 be subject to 离开舒适区 step out of one’s comfort zone 转基因食物 genetically modified food 为我自己辩护一下 in my defense 尝到了人生的艰辛 taste the hardship of life 明确的性别分工 a clear gender division 承担家务的人 housework undertaker 平等接受教育 have equal access to education 再就业 find new employment 繁重的体力劳动 strenuous manual labor 性别差异 gender gap/difference/disparity 工作表现 workplace performance 亲密的家庭 a closely-knit family 相互理解 mutual understanding 平衡……和…… strike a balance between … and … Sentences：1.Only by … , can sb do sth. 只有跟其他人合作，我们才能提高工作效率。 Only by cooperating with others, can we enhance our working efficiency. 2.老一辈一般比较节俭。他们看不惯年轻人花钱找乐子的想法。 Older generation are usually frugal. They don’t understand young people’s idea of spending money just for fun. 3.建造住宅楼有助于解决城市的拥挤问题。 Constructing residential building makes an effort in solving the problem of urban overcrowding. 4.不健康的生活方式可能使人们处于生病的危险之中。 An unhealthy lifestyle can put people in the danger of getting sick. 5.乡村地区给人们提供远离现代生活的压力和噪声的机会。 Rural areas provide people with opportunities to escape from the hustle and bustle of modern life.]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验七]]></title>
    <url>%2F2019%2F11%2F14%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%83%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204--使用数据库student，完成以下操作，并写出相应的代码--1.用函数实现：求某个专业选修了某门课程的学生人数，并调用函数求出计算机系“数据库”课程的选课人数。create function dept_num(@dept varchar(8),@cname varchar(20))returns intasbegin declare @num int select @num = count(*) from sc,course,student where sc.cno = course.cno and sc.sno = student.sno and course.cname = @cname and student.sdept = @dept return(@num) endselect dbo.dept_num('CS','数据库') as 人数--2.用内嵌表值函数实现：查询某个专业所有学生所选的每门课的平均成绩；调用该函数求出计算机系的所有课程的平均成绩。create function avg_all(@dept varchar(8))returns tableasreturn(select course.cname,avg(sc.grade) as 平均成绩 from course,sc,student where sc.cno = course.cno and sc.sno = student.sno and student.sdept = @dept group by course.cname)select *from dbo.avg_all('CS')--3.创建多语句表值函数，通过学号作为实参调用该函数，可显示该学生的姓名以及各门课的成绩和学分，调用该函数求出“200515002”的各门课成绩和学分。create function stu_show(@sno char(9))returns @stu_table table(sname nchar(6),cname varchar(20),grade int,credit int)asbegin insert @stu_table select sname,cname,grade,credit from student,sc,course where sc.cno = course.cno and sc.sno = student.sno and sc.sno = @snoreturnendselect *from dbo.stu_show('200515002')--4.编写一个存储过程，统计某门课程的优秀（90-100）人数、良好（80-89）人数、中等（70-79）人数、及格（60-69）人数和及格率，其输入参数是课程号，输出的是各级别人数及及格率，及格率的形式是90.25%，执行存储过程，在消息区显示1号课程的统计信息。create procedure clevel @cno char(4)asdeclare @great int,@good int,@fair int,@pass int,@all intselect @great = count(*) from sc where sc.cno = @cno and sc.grade &gt;= 90select @good = count(*) from sc where sc.cno = @cno and sc.grade &gt;= 80 and sc.grade &lt;= 89select @fair = count(*) from sc where sc.cno = @cno and sc.grade &gt;= 70 and sc.grade &lt;= 79select @pass = count(*) from sc where sc.cno = @cno and sc.grade &gt;= 60 and sc.grade &lt;= 69select @all = count(*) from sc where sc.cno = @cnoselect @great as 优秀人数,@good as 良好人数,@fair as 中等人数,@pass as 及格人数,convert(varchar,(@great+@good+@fair+@pass)*100/@all)+'%' as 及格率exec clevel '1'--5.创建一个带有输入参数的存储过程，该存储过程根据传入的学生名字，查询其选修的课程名和成绩，执行存储过程，在消息区显示赵箐箐的相关信息。create procedure pc_g @sname nchar(6)asselect cname,gradefrom student,sc,coursewhere student.sno = sc.sno and sc.cno = course.cno and student.sname = @snameexec pc_g '赵菁菁'--6.以基本表 course为基础，完成如下操作--生成显示如下报表形式的游标：报表首先列出学生的学号和姓名，然后在此学生下，列出其所选的全部课程的课程号、课程名和学分；依此类推，直到列出全部学生。declare @sno char(9),@sname nchar(6)declare @cno char(4),@cname varchar(20),@credit intdeclare stu_cursor insensitive cursor forselect student.sno,student.sname from studentopen stu_cursorfetch next from stu_cursor into @sno,@snamewhile @@fetch_status = 0begin print @sno +' '+@sname print'----------------------------' print 'cno cname credit' declare c_cursor cursor for select sc.cno,course.cname,course.credit from student,sc,course where student.sno=sc.sno and course.cno=sc.cno and student.sno=@sno open c_cursor fetch next from c_cursor into @cno,@cname,@credit while @@fetch_status = 0 begin print @cno+' '+@cname+' '+cast(@credit as char(4)) fetch next from c_cursor into @cno,@cname,@credit end print '==============================================' close c_cursor deallocate c_cursor fetch next from stu_cursor into @sno,@snameendclose stu_cursordeallocate stu_cursor--7.请设计一个存储过程实现下列功能：判断某个专业某门课程成绩排名为n的学生的成绩是否低于该门课程的平均分，如果低于平均分，则将其成绩改为平均分，否则输出学号、姓名、班号、课程号、课程名、成绩。（提示：可以在存储过程内部使用游标）。create procedure avg_p @dept char(4),@cno char(10),@n intasdeclare @sno char(10),@sgrade int,@avg_sgrade int,@sname char(6)declare cj cursor scroll forselect sc.Sno,Grade,Snamefrom sc,studentwhere sc.Cno=@cno and student.Sdept=@deptorder by Grade desc select @avg_sgrade=(select avg(Grade) from sc where sc.Cno=@cno) open cjfetch absolute @n from cj into @sno,@sgrade,@snameif(@sgrade&gt;@avg_sgrade) print @sno+' '+@sname+' '+@cno+' '+convert(char(6),@sgrade)elsebegin update sc set sc.Grade=@avg_sgrade where sc.Sno=@sno and sc.Cno=@cnoendclose cjdeallocate cjexec avg_p 'CS','1',3--8.对student数据库设计存储过程，设计程序实现更新某个专业某门课成绩排名为第2的学生的成绩改为90分。（提示可以使用存储过程内部使用游标）create procedure change_p @dept varchar(8),@cno char(10)asdeclare change_c scroll cursor forselect sc.sno,snamefrom sc,studentwhere student.sdept=@dept and sc.cno = @cnoorder by grade descopen change_cfetch absolute 2 from change_cupdate scset grade = 90close change_cdeallocate change_cexec change_p 'CS','1'--9.设计存储过程实现如果某个学生某门课程的成绩&gt;=60，那么就把这门课程的学分加到该学生的总学分（student表的total项）上create procedure add_p @sno char(9)asdeclare @grade int,@credit intdeclare add_c scroll cursor forselect sc.grade,course.creditfrom sc,coursewhere sc.sno = @sno and sc.cno = course.cnoopen add_cfetch next from add_c into @grade,@creditif(@grade &gt;= 60)begin update student set total = total + @creditendclose add_cdeallocate add_cexec add_p '200515001'--10.现有图书管理数据库， 其中包含如下几个表：--读者表：reader(学号，姓名，性别，余额)--借书表：lend（学号，书号，借书日期，应还日期，是否续借）--欠款表：debt(学号，日期，欠款金额)--还书表：return(学号，书号，还书日期) --请设计一个存储过程实现续借或还书操作，具体要求如下：--只有没有超期的书才可以续借（借书和续借时间都为30天），并修改应还日期，否则只能还书；--还书时删除借书表内的借阅记录，并向还书表中插入一条还书记录，注意还书日期为当前日期，--并且对超期图书，按照超期的天数计算出罚款金额（每天每本书罚款0.1元），并将罚款信息插入到欠款表中，--同时将罚款从读者表的余额里扣除。create procedure book as @sno char(20),@bno char(30)asdeclare @days int,@continue char(10)select @days = datediff(dd,借书日期,getdate()) from lendselect @continue = 是否续借 from lendif(@days&lt;=30 and @continue = '否') --未到期续借begin update lend set 应还日期 = dateadd(day,30,应还日期) set 是否续借 = '是'endelse if(@continue = '是' and datediff(dd,dateadd(day,@days,借书日期),应还日期)&gt;=0) --续借后还书begin delete from lend where sno = @sno and bno = @bno insert into return values(@sno,@bno,getdate())endelse if(datediff(day,getdate(),应还日期)&lt;0) --逾期后还书begin declare @debt money set @debt=datediff(day,应还日期,getdate())*0.1 insert into debt values(@sno,getdate(),@debt) update reader set 余额=余额-@debtend]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOEFL-Writing-Business and Economy]]></title>
    <url>%2F2019%2F11%2F11%2FTOEFL-Writing-Business-and-Economy%2F</url>
    <content type="text"><![CDATA[Expressions: 人口的增长 an increase in population 需求旺盛 be in great demand 出售，上市 be on the market/be launched to the market 自主经营 be self-employed 愿意/不愿意做某事 be willing/unwilling to do sth 促进经济发展 promote the development of economy/boost economy 建立事业 establish one’s career 因迟到打电话请假 call in late 打电话请病假 call in sick 升职 get promoted 赔偿 compensate for 失业补助 unemployment compensation 培养处理人际关系的技能 hone/cultivate the ability of interpersonal relationship 生产力下降 discourage/lower productivity 挣钱 earn money 发财 make a fortune 鼓励竞争 encourage the competition 就业 seek a career in 找到工作 find employment/a decent job 投资 target investment in 辞职 leave/quit one’s job 投诉 complain about 谋生 earn a living 获利 make a profit/generate profits 收支平衡 make ends meet 克服经济衰退 overcome economic crisis/recession/downturn/depression 跳槽 job-hopping 职业前景光明/黯淡 bright/bleak career prospects Advertising 误导公众 mislead the public 负债 get into debt 了解最新发生的事情 keep up to date with what is happening 经济问题 financial problems 更快了解实时新闻 have faster access to news in real time 经济压力 economic pressure 消费社会/文化 consumer society/culture 低收入家庭 less well-off/low-income family 来自贫困地区的人 people from deprived/disadvantaged areas 刺激购买冲动 evoke impulse shopping/impulse buying/impulsive purchases 入不敷出 cannot make both ends meet 大众媒体 mass media 还清债务 pay off debt 无处不在的 ubiquitous/pervasive/prevalent 过分购物 excess shopping/overbuying 虚假的 false/bogus 审查制度 censorship 对……实施审查 impose censorship on/censor 充斥着 be flooded/saturated with 媒体/广告炒作 media/advertising hype 购物狂 shopaholic 促销 promotion 市场营销手段 marketing tool 大规模的广告宣传活动 advertising campaigns 建立消费者对品牌的忠诚度 build consumer loyalty 公益广告 TV campaigns 电话营销 telemarketing 传单 flyers 墙画 wallscape 物质主义 materialism 消费主义 consumerism 家电 household appliances Positives of Advertising: Advertising is a key part of modern business. Companies need to tell customers about their products. Advertisements inform us about the choice we have. Without advertising we would have less choice. Advertising is a creative industry that employs many people. Without advertising there would be higher unemployment. Advertising is a form of modern art. Negatives of Advertising: Advertising may manipulate people’s decision. It aims to persuade people that buying a product will make them happier. Advertises focus on selling a brand image. They use glamorous, successful people.(celebrities) We now live in a consumer culture.(society) We are persuaded to follow the latest trends. We are encouraged to associate certain brands with a higher status. Advertisers often aim their marketing at children. Children can easily be influenced by advertisements. Children put pressure on parents to buy them things. Sentences:1.在家工作者应该是那些喜欢弹性工作制的人。 Home workers are supposed to be those who like flexible work schedule. 2.一般来说，年轻人有高尚的理想，会为了精神追求而努力奋斗。 Generally, the youth have noble ambitions, and they will strive for spiritual pursuit. 3.认为自己职业前景黯淡的员工容易萌生跳槽的念头。 Workers who think their career prospects are bleak are prone to having the idea of job-hopping. 4.负担一个大家庭的人不会轻易跳槽，因为他们需要一份稳定的收入。 Breadwinners who raise a big family are not prone to jumping ship, because they need a stable income. 5.与工作压力相关的问题包括更多的家庭纠纷和效率与生产力低下。 Issues related to working stress include more family/domestic disputes and lower productivity and efficiency. 6.只有精英分子才有自信在跳槽之后得到升职和高薪。 Only elites have confidence in getting promoted and higher salary after job-hopping. Practice:Getting a job in which you work with other people is better than getting a job in which you have to work alone. There are many things to consider in terms of work pattern. Different people have different ideas about whether or not work with other people. While some people like to work alone. Others prefer to work with colleagues. Personally, I believe it is better for employees to work with each other, because employees who work with others can hone their interpersonal skills, and the work mode could encourage the competition. Meanwhile, collaboration may inspire people’s creativity. Firstly, it is universally acknowledged that working with others can improve employees’ communication skills. At work, workers learn how to communicate with colleagues, bosses and customers. For example, what a programmer has to deal with is not only computer programs, but also figuring out what their partners are thinking, which means that workers must communicate and negotiate with colleagues frequently. Moreover, colleagues that workers cooperate with are their rivals as well. As we all know, cooperation and competition are the eternal themes of human growth. Working with one another creates competitive atmosphere and environment, so that employees can gain knowledge from people who are more excellent than themselves. What’s more, the stress that competition brings may stimulate their passion for work. Last but not least, teamwork definitely inspires people’s creativity. According to research, thirty years ago, only ten percent of Noble Prize winners worked in a team. Nowadays, the proportion of achievements achieved by teamwork has reached sixty percent. As the saying goes that two heads are better than one. The collision of people’s ideas always has the effects beyond the expectation. In conclusion, I hold an opinion that working alone may avoid amounts of troubles, but it is far from being an efficient work mode. Instead, working with other people is the better way not only to encourage the productivity but to make workers enjoy teamwork as well. That why we should undoubtedly work with each other.]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOEFL-Writing-Science and Technology]]></title>
    <url>%2F2019%2F11%2F11%2FTOEFL-Writing-Science-and-Technology%2F</url>
    <content type="text"><![CDATA[Expressions: 科技进步 scientific and technological advance/progress 科技创新 technological innovations 彻底改变了 overhaul/change sth radically / revolutionize 越来越流行 an increasing popularity of/increasing popular 信息时代 the Information Age/Era 信息爆炸 information explosion/overload 互联网的广泛使用 the extensive use of/the widespread use/proliferation of the Internet 社交网络/网站 social networking/social networking websites 促进交流 promote/facilitate communication 获取更多信息 have/gain more access to information 减少人力的机器 labor-saving machinery 代替人力的机器 labor-replacing machinery 鼠标一点 with the click of a mouse 键盘一敲 with the click on the keyboard 地理上的阻碍 geographical barrier 以惊人的速度 at an astonishing/lightning-fast rate/speed/pace 提高效率或生产率 enhance/boost/improve efficiency/productivity 网络犯罪 cyber crime 安全问题 security issue 侵犯某人隐私 violate/intrude/invade one’s privacy 身份盗窃或盗用 identity theft 剽窃 pirate/plagiarize 盗版的 pirated 视力的减弱 weakened eyesight/visual impairment 沉溺于或迷失于虚拟世界 indulge in/be lost in a virtual world 游离于现实世界之外 be isolated from the real world 削弱与家人、朋友的关系 weaken/distance the relationship with family and friends alienate them from family and friends 性格变得孤僻 become solitary Substitution: general substitutive development advance appearance advent/emergence 使用 have (equal/free/immediate) access to 随着……的广泛应用 as sth use worldwide explodes Sentences:1.互联网的出现加速了信息的传播。 The advent of Internet has accelerated the flow of the spread of information. 2.不可否认，互联网确实已经给全球的成人带来了更多的学习机会。 It is undeniable that the Internet has, indeed, made learning opportunities more accessible to adults around the globe. 3.电子书籍技术是现代文明中的革命性突破， 使人们得以摆脱厚重的书本。 E-book technology is a revolutionary breakthrough in modern civilization, which enable people to shake off thick and heavy printed books. 4.现有的信息技术还没有先进到可以确保（预防，阻止）人们在网络世界中的隐私不被泄露。 Existing information technology is not advanced enough to prevent information disclosure in cyber world. 5.随着网络犯罪数量的上升，互联网的可靠性受到高度怀疑。 With the increase in cyber crime, the reliability of the Internet has been highly suspected. 6.移动电话给语音通信带来了一场革命。 The mobile phone brings a revolution in the voice communication. Practice:Technology has made people’s lives simpler, rather than more complicated. When thinking about the issue that how has technology changed our lives, different people will have different ideas. While some people may believe technology has made people’s lives more complicated, I think that it enables people to live more simply. Because technology can help boost efficiency. Firstly, in terms of work and study, people gain easier access to information than before. For example, compared to the thick and heavy printed books in the past, we can find what we want on the Internet with the click of a mouse. Besides, labor-saving machinery plays an important role as well. Nowadays, massive amounts of work can be finished by computer programs, such as keeping bank accounts. As for me, I sometimes write a computer program to do some complicated calculations. Moreover, when it comes to the transportation, the ever-changing technology is even more impressive. Thanks to the advent of high-speed rail technology, we used to travel a day on a traditional train that could take a few hours. Taking myself as an example, when my parents drove me from home to the university in another city, it took almost a whole day. But after the high-speed line from home to my university being constructed, I can reunite with my family in about seven hours. Meanwhile, with the advances in airline, long-distance travel becomes more convenient. During the summer vacation, I traveled to Nanjing. From the time the plane took off to the time it landed, I even did not finish a bag of chips. In conclusion, I would like to say that technology has played a significant role in making people’s life much simpler. And It is undeniable that we can enjoy an efficient life with technology. This is why I support this viewpoint.]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOEFL-Writing-Health and Environment]]></title>
    <url>%2F2019%2F11%2F11%2FTOEFL-Writing-Health-and-Environment%2F</url>
    <content type="text"><![CDATA[EnvironmentWords:acid biodiversity contaminated deforestation afforestation vegetation ecosystem emissions erosion exhaust drought fertilizer greenhouse waste refuse waterway-河道 waters-水域 pristine-崭新的 pervasive-普遍的(贬) ubiquitous-普遍的(中) inexorable-无情的 phosphate-based-含磷的 Expressions: Government enact laws/enforce laws/introduce laws/legislation—regulate and punish impose “green taxes” on heavy industries invest (money/fund) in/make investment in—alternative energy clean energy/renewable energy/improve energy efficiency /public transportation/afforestation project educate/advocate—raise the public’s awareness of community service/activities/TV campaigns/invite celebrities to attract attention Individuals lead/live a green/low-carbon lifestyle use/take public transportation instead of private cars(green travel) reduce the carbon footprints reduce waste—recycle some useful materials paper, batteries and electronic devices sort household waste into different categories waste-sorting: recyclable, hazardous, kitchen, resitual collection banks participate in environment organizations conserve water resources useful expressions 损害 take one’s toll on/cause damage to A对B造成很大负担 A put a heavy burden on B 处于危险中（注意区分） be under threat from/be in danger of/put sth at risk 生态平衡 ecological balance/ecological equilibrium 可持续发展 sustainable development 环保主义者 environmentalist/conservationist 对环境无害的 environmentally-friendly 肥沃/贫瘠的土壤 fertile/infertile soil 臭氧层 ozone layer 耕地 arable land/farmland 增加农产品产量 boost crop yield 开采自然资源 exploit natural resources 短缺 be in a shortage/scarcity/dearth/lack of 消耗（某种资源） consume/deplete 耗尽（某种资源） use up/exhaust 给资源造成很大压力 put a strain on the already stretched resources 破坏自然资源 wreak havoc on natural resources 污水 effluent/sewage 排放 discharge 温室效应 greenhouse effect/global warming 严重的 severe/grave/grievous 白色污染产生的垃圾 non-biodegradable garbage/wastes that cannot decompose or breakdown/inorganic trash 恶化 deteriorate/aggravate 可再生资源 renewable resources 不可再生资源 non-renewable resources(metals, minerals, petroleum, natural gas, coal(后三种为fossil fuels)) 增强公众关于……的意识 raise/elevate the public awareness of sth 各国必须携手解决环境问题 countries on this planet must join forces/make a concerted effort/make collective efforts/unite to environmental problems 谴责而不是纵容 condemn rather than condone sth 严厉的措施 harsh/stiff action/measures Sentences:1.这意味着环境问题已经成为大城市人们关心的主要问题。 This indicated that environmental issues have become major concerns of citizens in metropolises. 2.造成严重污染的产业往往对国家税收和整体GDP的贡献最大。 The industries which caused severe contamination usually contribute to the tax revenue and overall GDP. 3.汽车尾气是空气污染的重要原因。 Car emissions contributes a lot to air pollution. 4.面对交通堵塞，大部分人只会抱怨政府。 Most people only complain about the government when face traffic congestions. 5.近几十年工业的快速发展给人们带来了很大的好处，但紧随而来的是我们正在忍受的严重的环境污染。 In recent decades, the rapid development of industry benefits people a lot, but what is following is that we are suffering from grave environmental contamination. HealthExpressions: health conditions chronic disorder diabetes, stroke, hypertension, respiratory, disease, malnutrition, obesity/overweight, heart disease, high cholesterol infectious diseases flu, skin disease, Aids incurable/terminal diseases cancer psychological problems low self-esteem, unsociable, inferior, depression, anxiety, autism poor/weakened eyesight visual impairment, myopia attention disorder healthy lifestyle proper/wholesome eating habits balanced diet, vegetarian regular physical activity jogging, swimming, climbing, yoga, do aerobics adequate sleep a good mood/positive outlook developing healthy habits healthy consulting nutrients fiber, vitamin, protein, mineral unhealthy lifestyle unwholesome diet imbalanced diet, junk food, high-calories, energy-dense, nutrient-poor, snack, fast food, meat-centered diet, binging/overeating, pre-prepared food/processed food, package food, fried food physical inactivity sedentary lifestyle, passive leisure pursuit, heavy TV viewing, addiction to cell phones environmental problems water/air/noise pollution, toxic substance, food pollution stress stressful life, workaholic smoking and alcoholism drug addiction Practice:The most effective way for the government to conserve energy is to increase the price of gasoline and electricity. Whether or not the most effective way for the government to conserve energy is to increase the price of gasoline and electricity is an often-debated topic. While some people may feel that the authority should raise the price thus reducing people’s use of energy, I do not believe that this is the most effective way. A world where energy use is strictly restricted cannot guarantee people’s well-being, and human development would be retarded. I believe that the price should be reasonably set and as stable as possible instead of being recklessly increased. Firstly, due to the increasing price of gasoline and electricity, the cost of living will correspondingly rise, which causes social problems. For instance, commuters, who choose public transport over driving owing to the increasing price of gasoline, may get exhausted from a longer commuting time than before. Then they will lack energy and patience in their work, which means their productivity may suffer. Lower productivity can hardly win them an opportunity to get promoted and decently paid. Without enough well-being, people tend to complain about the government. Moreover, people who have high income or profit from energy are indifferent to high prices. For example, what energy related industries will do when face the increasing price of gasoline and electricity is to correspondingly raise the price of products, or lower the quality to reduce the cost. After all, the extra cost is ultimately borne by consumers. Besides, industrial output will decrease more or less. Once supply is less than demand, the public interest will be influenced by soaring prices. Capitalists, by contrast, benefit from it. In conclusion, I hold an opinion that increasing the price of energy is far from being the best way to conserve energy. Rather than just focusing on raising prices, improving energy efficiency is a better idea. In this case, not only can people’s well-being be guaranteed, but also the problem of energy waste and environmental contamination will be significantly reduced.]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TOEFL-Writing-School and Education]]></title>
    <url>%2F2019%2F11%2F10%2FTOEFL-Writing-School%20and%20Education%2F</url>
    <content type="text"><![CDATA[Expressions: 教育目的（对个人） 1.德：提高道德标准 raise moral code/standards 成为好的社会成员 be a valuable/active social member 道德准则 a strong moral code 承担责任 assume/shoulder the responsibility to do 与他人合作 cooperate with others 价值体系 value system 遵纪守法 observe disciplines and obey laws 社区观念 sense of community 辨别是非 distinguish between right and wrong 团队精神 team spirit 2.智：理论知识+分析问题的能力 theoretical/academic knowledge + analyzing skills 独立和批判思考 independent and critical thinking 人际交往能力 interpersonal skills 领导力 leadership skills 组织能力 organizing skills 坚实的理论基础 a solid foundation in basics 动手操作的经验 hands-on experience 一手知识 first-hand knowledge 二手知识 second-hand knowledge 培养学生的竞争意识 cultivate/nurture a sense of competition in students 获得知识/技能 acquire/obtain knowledge/skills 3.体：身体健康+心理健康+养成良好的生活习惯 physical fitness/well-being 饮食健康 wholesome diet 强制的 compulsory 久坐的生活习惯 sedentary lifestyle 激发对体育的兴趣 stimulate students’ interests in sports 4.美：提升审美水平+文化修养 appreciation of Arts and Literature 自信 self-confidence 自律 self-discipline 自尊 self-esteem 自我培养 self-cultivation 内在动力 inner-motivation 毅力 persistence/perseverance/grit 5.劳：就业 obtain employment 合格的员工 a qualified employee 找工作 seek for employment 找一个好工作 find a decent job 找一份高薪的工作 find a well-paid job 找一份满意的工作 find a satisfying/satisfactory job 工作技能 employability skills 职业前景 career prospect 全面的 all-rounded/well-rounded 谋生 seek a livelihood 实习生 intern 实习 internship 职业道德 work ethics 就业率/失业率 employment/unemployment rate 教育目的（对社会） 提高就业率 improve employment rate 促进经济发展 boost economy 维护社会稳定 stabilize the society Other useful expressions 高等教育 tertiary education secondary primary/elementary 义务教育 compulsory education 全面发展 rounded development 课程 courses/take a course in 学科 subject/discipline 家长对小孩的教育 parenting domestic/family education home schooling(家庭学校) 学校对学生的教育 schooling 反馈 feedback 捣乱的学生 disruptive students 课程大纲 curriculum 应试教育 test-oriented education 死记硬背 learn by rote/cram/spoon-feeding 学位工厂 degree factory 学校是社会的一个缩影 a school is a society in miniature 双语的/多语的 bilingual/multilingual 以学生为中心的 learner-oriented 拖延症 procrastination 心理学文凭 a diploma in psychology Words and Expressions: Chinese Expression Example 从日常生活中学到 gain from daily life We can gain lots of knowledge, at least the common sense, from our daily life. 竞争力在于 competitive edge lies in Her competitive edge lies in the name of her university, which is the Peking University. 仅仅只是 nothing but Her stare betrayed nothing but muddle and inattention. 击成碎片 smash into pieces This overwhelming project smashed her into pieces. 假装看不到 turn a blind eye to They would even turn a blind eye to an old granny who falls down on the road crying out loud for help. 由他们自己决定 at their own discretion This is a decision students should make at their own discretion. 有责任 be obligatory It is obligatory for all staff in the lab to wear protective clothing. 回想，回顾 reflect on The old man reflected on the changes that had taken place since his youth. 放弃 let go of We can never let go of our responsibilities. Sentences:1.学校是应该教授更多的学术知识还是实用技能一直是一个有争议的问题。 It remains an controversial issue that schools are supposed to teach more theoretical knowledge or practical skills. 2.有些学生不想上学，因为他们感到来自同龄人的压力。 Some students don’t want to go to school, because they feel the stress from their peers. 3.老师应该鼓励学生用辩证的眼光看问题。 Teachers should encourage students to consider problems with dialectical view. 4.除了学习成绩，大学应该重视培养学生解决问题的能力、组织能力和人际交流能力。 Except for academic grades, college should pay attention to cultivate problem-solving, organizing and interpersonal skills. Practice：Which one of the reason is most important in helping students to study in colleges and universities? A. Having access to the university tutors who can provide individual instruction for the students who have difficulty in study. B. Having the help and encouragement from the family and friends. C. Having excellent teachers in high-school who can help the students before the university. Use you OWN words to illustrate your point. Don’t use your memorized examples.(300 words) During the university, students are supposed to enrich their knowledge constantly and be successful in their academic field. However, students are less likely to achieve rounded development on their own. This is the reason why undergraduates need others’ help. When thinking about who plays the most important role in helping students to study in universities, different people have different ideas. While some people may believe it is family and friends, and some consider it is high-school teachers, I think it is university tutors who is key. Firstly, university tutors are helpful in professional academic research. When students have difficulty in study, tutors can provide individual instruction. Since they have already studied this field for a long time. As for me, I major in computer science. When I have problems with programming, my tutor always proposes more accurate and comprehensible solutions patiently than mine. And I can learn programming thinking pattern from her suggestions. Thanks to her, I am familiar with programming and find it interesting now. Furthermore, tutors can broaden students’ professional horizon. Tutors may teach basic knowledge in the major, but what they are digging into is probably the most advanced in the field. Knowing any of those will be valuable for students. For example, I used to help my tutor who teaches machine learning with some additional jobs in his digital vein comparison project based on neutral network. My team members and I compared more than 70,000 digital vein images with our own naked eye. This seemingly boring task made me understand the boredom behind scientific research, so that I can be better prepared for it in the future. In conclusion, I really believe university tutors have a vital role to play in terms of helping us succeed in our university. With tutors help, students can not only acquire the knowledge which they are required to study at the moment, but also extend their vision to a further place in the professional field. This is why I support having access to the university tutors instead of seeking help from family, friends or high-school teachers.]]></content>
      <categories>
        <category>TOEFL</category>
      </categories>
      <tags>
        <tag>Writing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1003 Emergency]]></title>
    <url>%2F2019%2F11%2F09%2FPTA-Advanced-Level-1003-Emergency%2F</url>
    <content type="text"><![CDATA[As an emergency rescue team leader of a city, you are given a special map of your country. The map shows several scattered cities connected by some roads. Amount of rescue teams in each city and the length of each road between any pair of cities are marked on the map. When there is an emergency call to you from some other city, your job is to lead your men to the place as quickly as possible, and at the mean time, call up as many hands on the way as possible. Input Specification:Each input file contains one test case. For each test case, the first line contains 4 positive integers: N (≤500) - the number of cities (and the cities are numbered from 0 to N−1), M - the number of roads, C1 and C2 - the cities that you are currently in and that you must save, respectively. The next line contains N integers, where the i-th integer is the number of rescue teams in the i-th city. Then M lines follow, each describes a road with three integers c1, c2 and L, which are the pair of cities connected by a road and the length of that road, respectively. It is guaranteed that there exists at least one path from C1 to C2. Output Specification:For each test case, print in one line two numbers: the number of different shortest paths between C1 and C2, and the maximum amount of rescue teams you can possibly gather. All the numbers in a line must be separated by exactly one space, and there is no extra space allowed at the end of a line. Sample Input:123456785 6 0 21 2 1 5 30 1 10 2 20 3 11 2 12 4 13 4 1 Sample Output:12 4 Solution:注意： 1.题目要求的是最短路的条数而不是长度 2.memset的用法：将每个字节赋相同值（0x） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define INF 99999#define Ncity 501#define Nroad 10000using namespace std;int rescue[Ncity], map[Ncity][Ncity], dis[Nroad], vis[Ncity] = &#123; 0 &#125;, maxteam[Ncity], way[Ncity];int main() &#123; int N, M, C1, C2; int i, j, k, u, minn; scanf("%d%d%d%d", &amp;N, &amp;M, &amp;C1, &amp;C2); //memset(map, INF, sizeof(map)); //初始化地图 for (i = 0; i &lt; N; i++) &#123; for (j = 0; j &lt; N; j++) &#123; map[i][j] = INF; &#125; &#125; for (i = 0; i &lt; N; i++) //输入各城市救援队数量 scanf("%d", &amp;rescue[i]); for (i = 0; i &lt; M; i++) &#123; //输入路径 scanf("%d%d", &amp;j, &amp;k); scanf("%d", &amp;map[j][k]); map[k][j] = map[j][k]; &#125; for (i = 0; i &lt; N; i++) &#123; dis[i] = map[C1][i]; maxteam[i] = rescue[i]; way[i] = 1; if (dis[i] != INF &amp;&amp; i != C1) &#123; maxteam[i] += rescue[C1]; &#125; &#125; vis[C1] = 1; //标记起点 for (i = 1; i &lt; N; i++) &#123; //Dijkstra minn = INF; for (j = 0; j &lt; N; j++) &#123; if (vis[j] == 0 &amp;&amp; dis[j] &lt; minn) &#123; minn = dis[j]; u = j; &#125; &#125; vis[u] = 1; //标记u for (k = 0; k &lt; N; k++) &#123; //松弛u if (map[u][k] &lt; INF &amp;&amp; vis[k] == 0) &#123; //沿着一条路走 if (dis[k] &gt; dis[u] + map[u][k]) &#123; dis[k] = dis[u] + map[u][k]; maxteam[k] = maxteam[u] + rescue[k]; way[k] = way[u]; &#125; else if (dis[k] == dis[u] + map[u][k]) &#123; //出现了另一条路 way[k] += way[u]; if (maxteam[k] &lt; maxteam[u] + rescue[k]) &#123; maxteam[k] = maxteam[u] + rescue[k]; &#125; &#125; &#125; &#125; &#125; printf("%d %d", way[C2], maxteam[C2]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1002 A+B for Polynomials]]></title>
    <url>%2F2019%2F11%2F08%2FPTA-Advanced-Level-1002-A-B-for-Polynomials%2F</url>
    <content type="text"><![CDATA[This time, you are supposed to find A+B where A and B are two polynomials. Input Specification:Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial: K N1 aN1 N2 aN2 … NK aNK where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that 1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000. Output Specification:For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place. Sample Input:122 1 2.4 0 3.22 2 1.5 1 0.5 Sample Output:13 2 1.5 1 2.9 0 3.2 Solution:123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int main()&#123; int a, k; double b, n[1010] = &#123; 0 &#125;; for (int i = 0; i &lt; 2; i++) &#123; scanf("%d", &amp;k); while (k--) &#123; scanf("%d%lf", &amp;a, &amp;b); n[a] += b; &#125; &#125; int maxx, cnt = 0; //记录最大的N for (int i = 0; i &lt; 1010; i++) &#123; if (n[i]) &#123; cnt++; maxx = i; &#125; &#125; printf("%d", cnt); for (int i = maxx; i &gt;= 0; i--) if (n[i]) printf(" %d %.1lf", i, n[i]); return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验六]]></title>
    <url>%2F2019%2F11%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%85%AD%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214--以系统管理员身份登录到SQL Server服务器，并使用T-SQL语句实现以下操作：use student--1.将stu数据库中student表的sno定义为主键；alter table studentadd primary key(sno)--2.将数据库stu的表course的cno字段定义为主键，约束名称为cno_pk;alter table courseadd constraint cno_pkprimary key(cno)--3.为表course中的字段cname添加唯一值约束；alter table courseadd constraint cname_uqunique(cname)--4.将数据库stu的表sc的sno及cno字段组合定义为主键，约束名称为sc_pk;alter table scadd constraint sc_pkprimary key(sno,cno)--5.对于数据表sc的sno、cno字段定义为外码，使之与表student的主码sno及表course的主码cno对应，实现如下参照完整性：--1)删除student表中记录的同时删除sc表中与该记录sno字段值相同的记录；--2)修改student表某记录的sno时，若sc表中与该字段值对应的有若干条记录，则拒绝修改；--3)修改course表cno字段值时，该字段在sc表中的对应值也应修改；--4)删除course表一条记录时，若该字段在在sc表中存在，则删除该字段对应的记录；--5)向sc表添加记录时，如果该记录的sno字段的值在student中不存在，则拒绝插入；alter table scadd constraint sc_fk foreign key (sno) references student(sno) on delete cascade on update no action, foreign key (cno) references course(cno) on delete cascade on update cascade--6.定义check约束，要求学生学号sno必须为9位数字字符，且不能以0开头，第二三位皆为0；alter table studentadd constraint sno_ckcheck(sno like '[1-9]00[0-9][0-9][0-9][0-9][0-9][0-9]')--7.定义stu数据库中student表中学生年龄值在16-25范围内；alter table studentadd constraint sage_ckcheck(sage between 16 and 25)--8.定义stu数据库中student表中学生姓名长度在2-8之间；alter table studentadd constraint sname_ckcheck(sname like '__'|'___'|'____'|'_____'|'______'|'_______'|'________')--9.定义stu数据库中student表中学生性别列中只能输入“男”或“女”；alter table studentadd constraint ssex_ckcheck(ssex in ('男','女'))--10.定义stu数据库student表中学生年龄值默认值为20；alter table studentadd constraint sage_dfdefault 20 for sage--11.修改student表学生的年龄值约束可以为15-30范围内；alter table studentdrop constraint sage_ckalter table studentadd constraint sage_ckcheck(sage between 15 and 30)--12.删除上述唯一值约束、外键约束及check约束；alter table coursedrop constraint cname_uqalter table scdrop constraint sc_fkalter table studentdrop constraint sno_ck,sname_ck,ssex_ck,sage_ckuse xsgl--13.设计触发器实现如果一个学生转专业了，那么输出一条信息显示该学生各门课程的平均分。create trigger dept_chon xsfor updateasif update(专业)begin select cj.学号,avg(成绩) from cj,inserted where cj.学号 = inserted.学号 group by cj.学号end update xsset xs.专业 = '信息管理'where xs.学号 = '2006030101'--14.设计触发器实现如果成绩被修改了20分以上，则输出提示信息“修改成绩超过20分，请慎重”。create trigger grade_ck_tgon cjafter updateasbegin declare @pregrade numeric(18,0),@aftgrade numeric(18,0) select @pregrade = 成绩 from inserted select @aftgrade = 成绩 from deleted if((@pregrade-@aftgrade)&gt;20 or (@aftgrade-@pregrade)&gt;20) begin print'修改成绩超过20分，请慎重' endendupdate cjset cj.成绩 = 89where cj.学号 = '2006030101' and cj.课程号 = 'A001'--15.在student表中增加一列total,表示学生选课总门数，初始值为0。alter table xsadd total int default 0--定义一个触发器，实现如下完整性约束：当向SC表插入选课记录时，自动更新student表对应学号的total值,考虑成批插入数据的情况。create trigger sc_inserton cjafter insertasdeclare @total intselect @total = total from xsupdate xsset total = @total+1--16.设计一触发器，约束数据库系统课程的课容量为120。create trigger containon cjfor insert,updateasdeclare @num intselect @num = count(*) from deleted,kc where deleted.课程号 = kc.课程号 and kc.课程名='数据库系统'if @num &gt; 120begin rollback transaction print'数据库课程人数已满'end--17.设有两个表：商品库存表（商品编号，商品名称，库存数量，库存单价，库存金额）；商品销售表（商品编号，商品名称，购货商号，销售数量，销售单价，销售金额）；设计一触发器实现如下业务规则：--（1）保证在商品库存表中插入的数据，库存金额 = 库存数量 * 库存单价。create trigger insert_商品库存表 on 商品库存表 for insert as update 商品库存表 set 库存金额 = 库存数量 * 库存单价 where 商品编号 in (select 商品编号 from inserted)--（2）如果销售的商品不存在库存或者库存为零，则返回提示信息。否则自动减少商品库存表中对应商品的库存数量和库存金额。--建表并验证触发器的执行。create trigger insert_商品销售表 on 商品销售表 for insert as begin transaction if not exists ( select 库存数量 from 商品库存表 where 商品编号 in (select 商品编号 from inserted) ) begin raiseerror('错误！该商品不存在库存，不能销售！',16,1) rollback returnend if exists ( select 库存数量 from 商品库存表 where 商品编号 in (select 商品编号 from inserted) and 库存数量 &lt;= 0 ) begin raiseerror('错误！该商品库存小于等于0，不能销售!',16,1) rollback returnend--18．建立教师表（教工编号，姓名，专业，职称，工资）和工资变化表（教工编号，原工资，新工资）create table teacher(tno char(10) primary key,tname nchar(10),tdept char(16),tpro char(10),tsala money)create table sala_change(tno char(10),tpresala money,taftsala money)--设计触发器实现教授的工资不得低于4000元，如果低于4000元则自动改为4000元。create trigger sala_tgon teacherfor update,insertasdeclare @sala moneyselect @sala = tsala from teacherif @sala &lt; 4000begin update teacher set tsala = 4000 update sala_change set taftsala = 4000,tpresala = @salaend--19.使用第18题的两个表设计触发器实现如果教工的工资发生变化则向工资变化表插入一条记录，包含教工编号，原工资，新工资。create trigger insert_if_changeon teacherfor updateasif update(tsala)begin declare @tno char(10),@tpresala money,@taftsala money select @tno = tno from teacher select @tpresala = tsala from deleted select @taftsala = tsala from inserted insert into sala_change values(@tno,@tpresala,@taftsala)end]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL Server 数据类型]]></title>
    <url>%2F2019%2F11%2F05%2FSQL-Server-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Character 字符串： 数据类型 描述 存储 char(n) 固定长度的字符串。最多 8,000 个字符。 n varchar(n) 可变长度的字符串。最多 8,000 个字符。 varchar(max) 可变长度的字符串。最多 1,073,741,824 个字符。 text 可变长度的字符串。最多 2GB 字符数据。 Unicode 字符串： 数据类型 描述 存储 nchar(n) 固定长度的 Unicode 数据。最多 4,000 个字符。 nvarchar(n) 可变长度的 Unicode 数据。最多 4,000 个字符。 nvarchar(max) 可变长度的 Unicode 数据。最多 536,870,912 个字符。 ntext 可变长度的 Unicode 数据。最多 2GB 字符数据。 Binary 类型： 数据类型 描述 存储 bit 允许 0、1 或 NULL binary(n) 固定长度的二进制数据。最多 8,000 字节。 varbinary(n) 可变长度的二进制数据。最多 8,000 字节。 varbinary(max) 可变长度的二进制数据。最多 2GB 字节。 image 可变长度的二进制数据。最多 2GB。 Number 类型： 数据类型 描述 存储 tinyint 允许从 0 到 255 的所有数字。 1 字节 smallint 允许从 -32,768 到 32,767 的所有数字。 2 字节 int 允许从 -2,147,483,648 到 2,147,483,647 的所有数字。 4 字节 bigint 允许介于 -9,223,372,036,854,775,808 和 9,223,372,036,854,775,807 之间的所有数字。 8 字节 decimal(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 numeric(p,s) 固定精度和比例的数字。允许从 -10^38 +1 到 10^38 -1 之间的数字。p 参数指示可以存储的最大位数（小数点左侧和右侧）。p 必须是 1 到 38 之间的值。默认是 18。s 参数指示小数点右侧存储的最大位数。s 必须是 0 到 p 之间的值。默认是 0。 5-17 字节 smallmoney 介于 -214,748.3648 和 214,748.3647 之间的货币数据。 4 字节 money 介于 -922,337,203,685,477.5808 和 922,337,203,685,477.5807 之间的货币数据。 8 字节 float(n) 从 -1.79E + 308 到 1.79E + 308 的浮动精度数字数据。 参数 n 指示该字段保存 4 字节还是 8 字节。float(24) 保存 4 字节，而 float(53) 保存 8 字节。n 的默认值是 53。 4 或 8 字节 real 从 -3.40E + 38 到 3.40E + 38 的浮动精度数字数据。 4 字节 Date 类型： 数据类型 描述 存储 datetime 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 3.33 毫秒。 8 bytes datetime2 从 1753 年 1 月 1 日 到 9999 年 12 月 31 日，精度为 100 纳秒。 6-8 bytes smalldatetime 从 1900 年 1 月 1 日 到 2079 年 6 月 6 日，精度为 1 分钟。 4 bytes date 仅存储日期。从 0001 年 1 月 1 日 到 9999 年 12 月 31 日。 3 bytes time 仅存储时间。精度为 100 纳秒。 3-5 bytes datetimeoffset 与 datetime2 相同，外加时区偏移。 8-10 bytes timestamp 存储唯一的数字，每当创建或修改某行时，该数字会更新。timestamp 基于内部时钟，不对应真实时间。每个表只能有一个 timestamp 变量。 其他数据类型： 数据类型 描述 sql_variant 存储最多 8,000 字节不同数据类型的数据，除了 text、ntext 以及 timestamp。 uniqueidentifier 存储全局标识符 (GUID)。 xml 存储 XML 格式化数据。最多 2GB。 cursor 存储对用于数据库操作的指针的引用。 table 存储结果集，供稍后处理。]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验五]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%94%2F</url>
    <content type="text"><![CDATA[问题描述1.二叉树的创建（顺序存储&amp;链式存储）2.进行先序或中序或后序遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;iostream&gt;using namespace std;//二叉树顺序存储#define MAX_TREE_SIZE 100typedef int TElemType;TElemType Nil = 0;typedef TElemType SqBiTree[MAX_TREE_SIZE];SqBiTree bt;int SqBiTree_Len;void InitSqBiTree(SqBiTree &amp;bt)&#123; for (int i = 0; i &lt; MAX_TREE_SIZE; i++) bt[i] = Nil; printf("二叉树顺序初始化完毕\n"); return;&#125;void CreateSqBiTree(SqBiTree &amp;bt)&#123; printf("请输入结点个数（小于%d）\n", MAX_TREE_SIZE); scanf("%d", &amp;SqBiTree_Len); printf("请输入各结点的值（非零），空结点输入零，两结点之间用空格分开\n"); for (int i = 0; i &lt; SqBiTree_Len; i++) &#123; scanf("%d", &amp;bt[i]); if (i != 0 &amp;&amp; bt[(i + 1) / 2 - 1] == Nil &amp;&amp; bt[i] != Nil) &#123; printf("无双亲的非根节点,顺序存储失败！\n"); return; &#125; &#125; printf("二叉树顺序存储成功\n"); return;&#125;void SqPreOrderTraverse(SqBiTree bt,int i)&#123; if (bt[i - 1] != 0) &#123; printf("%d ", bt[i - 1]); SqPreOrderTraverse(bt, i * 2); SqPreOrderTraverse(bt, i * 2 + 1); &#125; return;&#125;//二叉树链式存储typedef enum PointerTag &#123; Link, Thread &#125;;typedef struct BiThrNode &#123; TElemType data; struct BiThrNode *lchild, *rchild; PointerTag LTag, RTag;&#125;BiThrNode, *BiThrTree;void CreateThrBiTree(BiThrTree &amp;T)&#123; char ch; cin &gt;&gt; ch; //scanf("%c", &amp;ch); if (ch == '#') T = NULL; else &#123; T = (BiThrNode*)malloc(sizeof(BiThrNode)); T-&gt;data = ch - '0'; CreateThrBiTree(T-&gt;lchild); CreateThrBiTree(T-&gt;rchild); &#125; return;&#125;void ThrPreOrderTraverse(BiThrNode* T)&#123; if (T != NULL) &#123; printf("%d ", T-&gt;data); ThrPreOrderTraverse(T-&gt;lchild); ThrPreOrderTraverse(T-&gt;rchild); &#125; return;&#125;int main()&#123; InitSqBiTree(bt); CreateSqBiTree(bt); printf("先序遍历顺序二叉树结果为："); SqPreOrderTraverse(bt, 1); printf("\n\n"); BiThrTree T; printf("请输入结点内容，空结点则输入#\n"); CreateThrBiTree(T); printf("先序遍历链式二叉树结果为："); ThrPreOrderTraverse(T); printf("\n"); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行 Python 代码能实现什么丧心病狂的功能？]]></title>
    <url>%2F2019%2F11%2F04%2F%E4%B8%80%E8%A1%8C-Python-%E4%BB%A3%E7%A0%81%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%BB%80%E4%B9%88%E4%B8%A7%E5%BF%83%E7%97%85%E7%8B%82%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1.一行代码打印乘法口诀1print('\n'.join([' '.join(["%2s x%2s = %2s"%(j,i,i*j) for j in range(1,i+1)]) for i in range(1,10)])) 2.一行代码打印迷宫1print(''.join(__import__('random').choice('\u2571\u2572') for i in range(50*24))) 3.一行代码（土味）表白1print('\n'.join([''.join([('Love'[(x-y) % len('Love')] if ((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3 &lt;= 0else' ') for x in range(-30, 30)]) for y in range(30, -30, -1)])) 4.一行代码打印龟龟（/滑稽）1print('\n'.join([''.join(['*' if abs((lambda a:lambda z,c,n:a(a,z,c,n))(lambda s,z,c,n:z if n==0 else s(s,z*z+c,c,n-1))(0,0.02*x+0.05j*y,40))&lt;2 else ' ' for x in range(-80,20)]) for y in range(-20,20)]))]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python十大装B语法]]></title>
    <url>%2F2019%2F11%2F04%2FPython%E5%8D%81%E5%A4%A7%E8%A3%85B%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Python 是一种代表简单思想的语言，其语法相对简单，很容易上手。不过，如果就此小视 Python 语法的精妙和深邃，那就大错特错了。本文精心筛选了最能展现 Python 语法之精妙的十个知识点，并附上详细的实例代码。如能在实战中融会贯通、灵活使用，必将使代码更为精炼、高效，同时也会极大提升代码B格，使之看上去更老练，读起来更优雅。1.for-else什么？不是 if 和 else 才是原配吗？No，你可能不知道，else 是个脚踩两只船的家伙，for 和 else 也是一对，而且是合法的。十大装B语法，for-else 绝对算得上南无湾！不信，请看： 12345678910&gt;&gt;&gt; for i in [1,2,3,4]: print(i)else: print(i, '我是else')12344 我是else 如果在 for 和 else 之间（循环体内）有第三者 if 插足，也不会影响 for 和 else 的关系。因为 for 的级别比 if 高，else 又是一个攀附权贵的家伙，根本不在乎是否有 if，以及是否执行了满足 if 条件的语句。else 的眼里只有 for，只要 for 顺利执行完毕，else 就会屁颠儿屁颠儿地跑一遍： 123456789&gt;&gt;&gt; for i in [1,2,3,4]: if i &gt; 2: print(i)else: print(i, '我是else')344 我是else 那么，如何拆散 for 和 else 这对冤家呢？只有当 for 循环被 break 语句中断之后，才会跳过 else 语句： 12345678&gt;&gt;&gt; for i in [1,2,3,4]: if i&gt;2: print(i) breakelse: print(i, '我是else')3 2.一颗星()和两颗星(*)有没有发现，星(*)真是一个神奇的符号！想一想，没有它，C语言还有啥好玩的？同样，因为有它，Python 才会如此的仪态万方、风姿绰约、楚楚动人！Python 函数支持默认参数和可变参数，一颗星表示不限数量的单值参数，两颗星表示不限数量的键值对参数。 我们还是举例说明吧：设计一个函数，返回多个输入数值的和。我们固然可以把这些输入数值做成一个list传给函数，但这个方法，远没有使用一颗星的可变参数来得优雅： 12345678&gt;&gt;&gt; def multi_sum(*args): s = 0 for item in args: s += item return s&gt;&gt;&gt; multi_sum(3,4,5)12 Python 函数允许同时全部或部分使用固定参数、默认参数、单值（一颗星）可变参数、键值对（两颗星）可变参数，使用时必须按照前述顺序书写。 123456789&gt;&gt;&gt; def do_something(name, age, gender='男', *args, **kwds): print('姓名：%s，年龄：%d，性别：%s'%(name, age, gender)) print(args) print(kwds)&gt;&gt;&gt; do_something('xufive', 50, '男', 175, 75, math=99, english=90)姓名：xufive，年龄：50，性别：男(175, 75)&#123;'math': 99, 'english': 90&#125; 3.三元表达式熟悉 C/C++ 的程序员，初上手 python 时，一定会怀念经典的三元操作符，因为想表达同样的思想，用python 写起来似乎更麻烦。比如： 1234567&gt;&gt;&gt; y = 5&gt;&gt;&gt; if y &lt; 0: print('y是一个负数')else: print('y是一个非负数')y是一个非负数 其实，python 是支持三元表达式的，只是稍微怪异了一点，类似于我们山东人讲话。比如，山东人最喜欢用倒装句：打球去吧，要是不下雨的话；下雨，咱就去自习室。翻译成三元表达式就是： 1打球去吧 if 不下雨 else 去自习室 来看看三元表达式具体的使用： 123&gt;&gt;&gt; y = 5&gt;&gt;&gt; print('y是一个负数' if y &lt; 0 else 'y是一个非负数')y是一个非负数 python 的三元表达式也可以用来赋值： 1234&gt;&gt;&gt; y = 5&gt;&gt;&gt; x = -1 if y &lt; 0 else 1&gt;&gt;&gt; x1 4.with-aswith 这个词儿，英文里面不难翻译，但在 Python 语法中怎么翻译，我还真想不出来，大致上是一种上下文管理协议。作为初学者，不用关注 with 的各种方法以及机制如何，只需要了解它的应用场景就可以了。with 语句适合一些事先需要准备，事后需要处理的任务，比如，文件操作，需要先打开文件，操作完成后需要关闭文件。如果不使用with，文件操作通常得这样： 12345fp = open(r"D:\CSDN\Column\temp\mpmap.py", 'r')try: contents = fp.readlines()finally: fp.close() 如果使用 with - as，那就优雅多了： 12&gt;&gt;&gt; with open(r"D:\CSDN\Column\temp\mpmap.py", 'r') as fp: contents = fp.readlines() 5.列表推导式在各种稀奇古怪的语法中，列表推导式的使用频率应该时最高的，对于代码的简化效果也非常明显。比如，求列表各元素的平方，通常应该这样写（当然也有其他写法，比如使用map函数）： 1234567&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; result = list()&gt;&gt;&gt; for i in a: result.append(i*i)&gt;&gt;&gt; result[1, 4, 9, 16, 25] 如果使用列表推导式，看起来就舒服多了： 1234&gt;&gt;&gt; a = [1, 2, 3, 4, 5]&gt;&gt;&gt; result = [i*i for i in a]&gt;&gt;&gt; result[1, 4, 9, 16, 25] 事实上，推导式不仅支持列表，也支持字典、集合、元组等对象。有一篇博文《一行 Python 代码能实现什么丧心病狂的功能？》，里面的例子，都是列表推导式实现的。 6.列表索引的各种骚操作Python 引入负整数作为数组的索引，这绝对是喜大普奔之举。想想看，在C/C++中，想要数组最后一个元素，得先取得数组长度，减一之后做索引，严重影响了思维的连贯性。Python语言之所以获得成功，我个人觉得，在诸多因素里面，列表操作的便捷性是不容忽视的一点。请看： 123456789101112131415161718192021&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; a[2:4][2, 3]&gt;&gt;&gt; a[3:][3, 4, 5]&gt;&gt;&gt; a[1:][1, 2, 3, 4, 5]&gt;&gt;&gt; a[:][0, 1, 2, 3, 4, 5]&gt;&gt;&gt; a[::2][0, 2, 4]&gt;&gt;&gt; a[1::2][1, 3, 5]&gt;&gt;&gt; a[-1]5&gt;&gt;&gt; a[-2]4&gt;&gt;&gt; a[1:-1][1, 2, 3, 4]&gt;&gt;&gt; a[::-1][5, 4, 3, 2, 1, 0] 如果说，这些你都很熟悉，也经常用，那么接下来这个用法，你一定会感觉很神奇： 12345678&gt;&gt;&gt; a = [0, 1, 2, 3, 4, 5]&gt;&gt;&gt; b = ['a', 'b']&gt;&gt;&gt; a[2:2] = b&gt;&gt;&gt; a[0, 1, 'a', 'b', 2, 3, 4, 5]&gt;&gt;&gt; a[3:6] = b&gt;&gt;&gt; a[0, 1, 'a', 'a', 'b', 4, 5] 7.lambda函数lambda 听起来很高大上，其实就是匿名函数（了解js的同学一定很熟悉匿名函数）。匿名函数的应用场景是什么呢？就是仅在定义匿名函数的地方使用这个函数，其他地方用不到，所以就不需要给它取个阿猫阿狗之类的名字了。下面是一个求和的匿名函数，输入参数有两个，x和y，函数体就是x+y，省略了return关键字。 123&gt;&gt;&gt; lambda x,y: x+y&lt;function &lt;lambda&gt; at 0x000001B2DE5BD598&gt;&gt;&gt;&gt; (lambda x,y: x+y)(3,4) # 因为匿名函数没有名字，使用的时候要用括号把它包起来 匿名函数一般不会单独使用，而是配合其他方法，为其他方法提供内置的算法或判断条件。比如，使用排序函数sorted对多维数组或者字典排序时，就可以指定排序规则。 12345&gt;&gt;&gt; a = [&#123;'name':'B', 'age':50&#125;, &#123;'name':'A', 'age':30&#125;, &#123;'name':'C', 'age':40&#125;]&gt;&gt;&gt; sorted(a, key=lambda x:x['name']) # 按姓名排序[&#123;'name': 'A', 'age': 30&#125;, &#123;'name': 'B', 'age': 50&#125;, &#123;'name': 'C', 'age': 40&#125;]&gt;&gt;&gt; sorted(a, key=lambda x:x['age']) # 按年龄排序[&#123;'name': 'A', 'age': 30&#125;, &#123;'name': 'C', 'age': 40&#125;, &#123;'name': 'B', 'age': 50&#125;] 再举一个数组元素求平方的例子，这次用map函数： 12345&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; for item in map(lambda x:x*x, a): print(item, end=', ')1, 4, 9, 8.yield以及生成器和迭代器要理解 yield，得先了解 generator（生成器）。要了解generator，得先知道 iterator（迭代器）。哈哈哈，绕晕了吧？算了，我还是说白话吧。 话说py2时代，range()返回的是list，但如果range(10000000)的话，会消耗大量内存资源，所以，py2又搞了一个xrange()来解决这个问题。py3则只保留了xrange()，但写作range()。xrange()返回的就是一个迭代器，它可以像list那样被遍历，但又不占用多少内存。generator（生成器）是一种特殊的迭代器，只能被遍历一次，遍历结束，就自动消失了。总之，不管是迭代器还是生成器，都是为了避免使用list，从而节省内存。那么，如何得到迭代器和生成器呢？ python内置了迭代函数 iter，用于生成迭代器，用法如下： 12345678&gt;&gt;&gt; a = [1,2,3]&gt;&gt;&gt; a_iter = iter(a)&gt;&gt;&gt; a_iter&lt;list_iterator object at 0x000001B2DE434BA8&gt;&gt;&gt;&gt; for i in a_iter: print(i, end=', ')1, 2, 3, yield 则是用于构造生成器的。比如，我们要写一个函数，返回从0到某正整数的所有整数的平方，传统的代码写法是这样的： 12345678&gt;&gt;&gt; def get_square(n): result = list() for i in range(n): result.append(pow(i,2)) return result&gt;&gt;&gt; print(get_square(5))[0, 1, 4, 9, 16] 但是如果计算1亿以内的所有整数的平方，这个函数的内存开销会非常大，这是 yield 就可以大显身手了： 1234567891011&gt;&gt;&gt; def get_square(n): for i in range(n): yield(pow(i,2))&gt;&gt;&gt; a = get_square(5)&gt;&gt;&gt; a&lt;generator object get_square at 0x000001B2DE5CACF0&gt;&gt;&gt;&gt; for i in a: print(i, end=', ')0, 1, 4, 9, 16, 如果再次遍历，则不会有输出了。 9.装饰器刚弄明白迭代器和生成器，这又来个装饰器，Python 咋这么多器呢？的确，Python 为我们提供了很多的武器，装饰器就是最有力的武器之一。装饰器很强大，我在这里尝试从需求的角度，用一个简单的例子，说明装饰器的使用方法和制造工艺。 假如我们需要定义很多个函数，在每个函数运行的时候要显示这个函数的运行时长，解决方案有很多。比如，可以在调用每个函数之前读一下时间戳，每个函数运行结束后再读一下时间戳，求差即可；也可以在每个函数体内的开始和结束位置上读时间戳，最后求差。不过，这两个方法，都没有使用装饰器那么简单、优雅。下面的例子，很好地展示了这一点。 1234567891011121314151617181920&gt;&gt;&gt; import time&gt;&gt;&gt; def timer(func): def wrapper(*args,**kwds): t0 = time.time() func(*args,**kwds) t1 = time.time() print('耗时%0.3f'%(t1-t0,)) return wrapper&gt;&gt;&gt; @timerdef do_something(delay): print('函数do_something开始') time.sleep(delay) print('函数do_something结束')&gt;&gt;&gt; do_something(3)函数do_something开始函数do_something结束耗时3.077 timer() 是我们定义的装饰器函数，使用@把它附加在任何一个函数（比如do_something）定义之前，就等于把新定义的函数，当成了装饰器函数的输入参数。运行 do_something() 函数，可以理解为执行了timer(do_something) 。细节虽然复杂，不过这么理解不会偏差太大，且更易于把握装饰器的制造和使用。 10.巧用断言assert所谓断言，就是声明表达式的布尔值必须为真的判定，否则将触发 AssertionError 异常。严格来讲，assert是调试手段，不宜使用在生产环境中，但这不影响我们用断言来实现一些特定功能，比如，输入参数的格式、类型验证等。 1234567891011121314151617181920&gt;&gt;&gt; def i_want_to_sleep(delay): assert(isinstance(delay, (int,float))), '函数参数必须为整数或浮点数' print('开始睡觉') time.sleep(delay) print('睡醒了')&gt;&gt;&gt; i_want_to_sleep(1.1)开始睡觉睡醒了&gt;&gt;&gt; i_want_to_sleep(2)开始睡觉睡醒了&gt;&gt;&gt; i_want_to_sleep('2')Traceback (most recent call last): File "&lt;pyshell#247&gt;", line 1, in &lt;module&gt; i_want_to_sleep('2') File "&lt;pyshell#244&gt;", line 2, in i_want_to_sleep assert(isinstance(delay, (int,float))), '函数参数必须为整数或浮点数'AssertionError: 函数参数必须为整数或浮点数]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验五]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%94%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879--1．创建一windows用户（名字自定），用sql语句建立windows验证模式的登录名。默认数据库为student--2．用sql语句和系统存储过程建立登录名sqluser,密码为1234 --sqlcreate login sqluser with password='1234',default_database=student--存储过程exec sp_addlogin 'sqluser','1234'--3．为student数据库新建用户u1，其登录名为sqluser。create user u1 from login sqluser--4．新建登录usersf，并将其加入到sysadmin固定服务器角色中。exec sp_addsrvrolemember 'usersf','sysadmin'--5．将student用户usersf（登录名为usersf）加入到db_owner角色中，使其全权负责该数据库,并验证其权限。exec sp_addsrvrolemember 'db_owner','usersf'--6．为SPJ数据库新建用户u2，u3，其登录名分别为u2，u3。create login u2 with password='',default_database=SPJcreate user u2 for login u2create login u3 with password='',default_database=SPJcreate user u3 for login u3--（1）授予用户u2对S表有SELECT 权，对P表颜色（COLOR）具有更新权限；grant selecton Sto u2grant update(color)on Pto u2--（2）u2将其拥有的权限授予u3；grant u2to u3--（3）用sql语句逐一验证u2、u3所获得的权限。select * from Supdate Pset color='红'--（4）撤销用户u3所获得的权限，并验证。revoke selecton table Sfrom u3revoke update(color)on table Pfrom u3--7.在student数据库中建立角色operate,该角色具有对student和course表的查询权限；具有对表sc的插入和修改权限。create role operategrant selecton studentto operategrant selecton courseto operategrant update,inserton scto operate--8.拒绝用户u1对sc表的修改权限。deny update on scto u1 cascade--9.使用存储过程将角色operate赋给用户u1,并用sql语句验证其权限。（特别验证u1对sc表的修改权限）exec sp_addrolemember 'operate','u1'select *from studentselect *from courseupdate scset grade = 100where sno = '200515001' and cno = '1']]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[洛谷 P1020 导弹拦截]]></title>
    <url>%2F2019%2F10%2F30%2F%E6%B4%9B%E8%B0%B7-P1020-%E5%AF%BC%E5%BC%B9%E6%8B%A6%E6%88%AA%2F</url>
    <content type="text"><![CDATA[题目描述某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。 输入导弹依次飞来的高度（雷达给出的高度数据是≤50000的正整数），计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入格式1行，若干个整数（个数≤100000） 输出格式2行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。 输入输出样例输入 #1 1389 207 155 300 299 170 158 65 输出 #1 1262 说明/提示为了让大家更好地测试n方算法，本题开启spj，n方100分，nlogn200分 每点两问，按问给分 题解12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int a[100010], d1[100010], d2[100010], n;inline bool read(int &amp;x) &#123; char c = getchar(); if (c == EOF) return false; while (c &gt; '9' || c &lt; '0') c = getchar(); while (c &gt;= '0'&amp;&amp;c &lt;= '9') &#123; x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c ^ 48); c = getchar(); &#125; return true;&#125;int main() &#123; //freopen("1.txt", "r", stdin); //freopen("2.txt", "w", stdout); while (read(a[++n])); n--; int len1 = 1, len2 = 1; d1[1] = d2[1] = a[1]; for (int i = 2; i &lt;= n; i++) &#123; if (d1[len1] &gt;= a[i]) d1[++len1] = a[i]; else *upper_bound(d1 + 1, d1 + 1 + len1, a[i], greater&lt;int&gt;()) = a[i]; if (d2[len2] &lt; a[i]) d2[++len2] = a[i]; else *lower_bound(d2 + 1, d2 + 1 + len2, a[i]) = a[i]; &#125; printf("%d\n%d", len1, len2); //fclose(stdin); //fclose(stdout) return 0;&#125;]]></content>
      <categories>
        <category>LuoGu</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA(Advanced Level) 1001 A+B Format]]></title>
    <url>%2F2019%2F10%2F28%2FPTA-Advanced-Level-1001-A-B-Format%2F</url>
    <content type="text"><![CDATA[Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits). Input Specification:Each input file contains one test case. Each case contains a pair of integers a and b where −10^6 ≤a,b≤10^6. The numbers are separated by a space. Output Specification:For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format. Sample Input:1-1000000 9 Sample Output:1-999,991 Solution:12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cmath&gt; using namespace std; int main()&#123; int a, b, c, ans[10], flag = 0, n = 1; scanf("%d%d", &amp;a, &amp;b); c = a + b; if (c == 0) &#123; //第一次提交没有想到a+b为0这一点 printf("0"); return 0; &#125; if (c &gt; 0) //determine the positive and negative flag = 1; c = abs(c); while (c) &#123; //convert the sum into an array ans[n++] = c % 10; c /= 10; &#125; if (flag == 0) printf("-"); for (int i = n - 1; i &gt; 0; i--) &#123; if (i % 3 == 0 &amp;&amp; i != n - 1) printf(","); printf("%d", ans[i]); &#125; return 0;&#125;]]></content>
      <categories>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>Advanced Level</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验四]]></title>
    <url>%2F2019%2F10%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229--一、对xsgl数据库完成下列操作要求：use xsgl--1.将被全部学生都选修了的课程的总学分改为4学分update kc set kc.学分 = 4where kc.课程号 in (select kc.课程号 from kc where not exists (select * from xs where not exists (select * from cj where cj.课程号 = kc.课程号 and cj.学号 = xs.学号)))--2.从学生表删除没有选课的学生delete from xswhere xs.学号 not in (select cj.学号 from cj)--3.将每个学生的平均分，总分和选课门数插入到数据库中（学号，姓名，平均分，总分，选课门数）create table new(学号 char(10),姓名 nchar(10),平均分 numeric(10,2),总分 numeric(10,2),选课门数 smallint)insert into newselect xs.学号,xs.姓名,avg(cj.成绩),sum(cj.成绩),count(cj.课程号)from xs left join cj on xs.学号=cj.学号group by xs.学号,xs.姓名--4.创建每门课程的平均分和选课人数的视图（课程号，课程名，平均分，人数）create view Course(课程号,课程名,平均分,人数)asselect kc.课程号,kc.课程名,avg(cj.成绩) 平均分,count(cj.学号) 人数from kc left join cj on (kc.课程号 = cj.课程号)group by kc.课程号,kc.课程名--5.将李强同学从学生表删除（提示应该先删除李强同学的选课记录）delete from cjwhere cj.学号 = (select xs.学号 from xs where xs.姓名 = '李强')delete from xswhere xs.姓名 = '李强'--6.插入一条选课记录（具体内容自己选）insertinto xsvalues('2018008003','彭于晏','男',null,null,null,null,null)insertinto cjvalues('2018008003','A001',null)--7.创建网络工程专业的学生的选课信息的视图，要求视图包含，学号，姓名，专业，课程号，课程名，成绩create view IT(学号,姓名,专业,课程号,课程名,成绩)asselect xs.学号,xs.姓名,xs.专业,kc.课程号,kc.课程名,cj.成绩from xs left join cj on xs.学号 = cj.学号 right join kc on cj.课程号 = kc.课程号where xs.专业 = '网络工程'--8.查询网络工程专业的各科的平均成绩，要求使用第7题创建的视图进行查询select IT.课程号,avg(IT.成绩) 平均成绩from ITgroup by IT.课程号--9.查询被信息管理专业的学生都选修了的课程的课程号，课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from xs where xs.专业 = '信息管理' and not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--10.显示选修课程数最多的学号及选修课程数最少的学号，姓名（使用派生表实现）select xs.学号,xs.姓名,count(*) 门数from xs,cj,(select top 1 count(*) from cj group by cj.学号 order by count(*) desc) Maxx(门数), (select top 1 count(*) from cj group by cj.学号 order by count(*)) Minn(门数)where cj.学号 = xs.学号group by xs.学号,xs.姓名,Maxx.门数,Minn.门数having count(*) = Maxx.门数 or count(*) = Minn.门数--11.查询每个学生成绩高于自己的平均成绩的学号，姓名，课程号和成绩（使用派生表实现）select xs.学号,xs.姓名,cj.课程号,cj.成绩from xs,cj,(select cj1.学号,avg(cj1.成绩) 平均成绩 from cj cj1 group by cj1.学号) avg_gradewhere cj.学号 = avg_grade.学号 and xs.学号 = cj.学号 and cj.成绩 &gt; avg_grade.平均成绩--12.自己验证with check option的作用create view IEasselect xs.学号,xs.姓名,xs.性别,xs.专业from xswhere xs.专业 = '网络工程'with check optioninsert into IE(学号,姓名)values('2018008002','吴彦祖') --13.创建一个网络工程系的学生基本信息的视图MA_STUDENT，在此视图的基础上，再定义一个该专业女生信息的视图，然后再删除MA_STUDENT，观察执行情况。create view MA_STUDENTasselect *from xswhere xs.专业 = '网络工程'with check optioncreate view Femaleasselect *from MA_STUDENTwhere MA_STUDENT.性别 = '女'drop view MA_STUDENT--14.查询和程明同龄的学生的学号和姓名以及年龄select xs.学号,xs.姓名,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) = (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.姓名 = '程明')--15.查询没有被全部的学生都选修的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere exists (select * from xs where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))--16.查询选课学生包含了选英语的全部学生的课程的课程号和课程名select kc.课程号,kc.课程名from kcwhere not exists (select * from cj where cj.课程号 = (select kc.课程号 from kc where kc.课程名 = '英语') and not exists (select * from cj c where c.学号 = cj.学号 and c.课程号 = kc.课程号))--二、使用Northwind数据库完成下列操作use Northwind--1. 将员工lastname是: Peacock处理的订单中购买数量超过50的商品折扣改为七折update [Order Details]set Discount = 0.3where [Order Details].Quantity &gt; 50 and [Order Details].OrderID in (select O1.OrderID from [Order Details] O1,Employees,Orders where Employees.EmployeeID = Orders.EmployeeID and Orders.OrderID = O1.OrderID and Employees.LastName = 'Peacock' and O1.Quantity &gt; 50)--2. 删除lastname是: Peacock处理的所有订单deletefrom [Order Details]where [Order Details].OrderID in (select distinct O1.OrderID from [Order Details] O1,Employees,Orders where O1.OrderID = Orders.OrderID and Orders.EmployeeID = Employees.EmployeeID and Employees.LastName = 'Peacock')deletefrom Orderswhere Orders.EmployeeID = (select Employees.EmployeeID from Employees where Employees.LastName = 'Peacock')--3. 将每个订单的订单编号，顾客编号，产品总数量，总金额插入到数据库中create table OrderInfo(订单编号 int,顾客编号 nchar(5),产品总数量 smallint,总金额 money)insertinto OrderInfoselect Orders.OrderID,Orders.CustomerID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1- [Order Details].Discount)) 金额from [Order Details],Orderswhere [Order Details].OrderID = Orders.OrderIDgroup by Orders.OrderID,Orders.CustomerID--4. 插入一个新的订单，要求该订单购买了商品编号为5,7,9的商品。（5号商品买了10个，7号买了20个，9号买了15个，都没有折扣）insert into [Order Details]values('10325','5', '50', '10', '0')insert into [Order Details]values('10325','7', '70', '20', '0')insert into [Order Details]values('10325','9', '90', '15', '0')--5. 将每年每个员工处理订单的数量和订单的总金额创建为视图create view Employasselect Employees.EmployeeID,datename(yy,Orders.OrderDate) 年份, count(distinct Orders.OrderID) 订单数量,sum([Order Details].Quantity) 数量, sum([Order Details].Quantity*[Order Details].UnitPrice*(1-[Order Details].Discount)) 订单总金额from Employees left join Orders on Employees.EmployeeID=Orders.EmployeeID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Employees.EmployeeID,datename(yy,Orders.OrderDate)--6. 购买了CustomerID是‘VINET’用户所购买的全部商品的用户的CustomerID和CompanyName。select distinct Customers.CustomerID,Customers.CompanyNamefrom Customers,Orders where Customers.CustomerID = Orders.CustomerID and not exists (select * from Orders o2,Customers c2 where o2.CustomerID = c2.CustomerID and o2.CustomerID = 'VINET' and not exists (select * from Orders o3 where o3.CustomerID = Orders.CustomerID))]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验三]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337--一.对xsgl数据库完成以下操作--1.查询没有选修英语的学生的学号，姓名和课程号，课程名，成绩select xs.学号,xs.姓名,kc.课程号,kc.课程名,cj.成绩from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号 and kc.课程名 &lt;&gt; '英语'--2.查询英语成绩高于英语的平均成绩的学生的学号，姓名，成绩select xs.学号,xs.姓名,cj.成绩from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.成绩 &gt; (select avg(cj.成绩) from kc,cj where cj.课程号 = kc.课程号 and kc.课程名 = '英语')--3.查询选修了英语和高数(数学)的学生的学号和姓名（要求使用两种方法实现）select xs.学号,xs.姓名from xs,cj,kcwhere xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '英语' and cj.学号 in (select cj.学号 from cj,xs,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and kc.课程名 = '数学')select xs.学号,xs.姓名from xs,cj,kc where xs.学号 = cj.学号 and cj.课程号 = kc.课程号 and 课程名 = '英语' and xs.学号 in (select 学号 from cj where 课程号 = (select 课程号 from kc where 课程名 = '数学'))--4.查询没有选修程明所选修的全部课程的学生的姓名select xs.姓名from xs,cjwhere xs.学号 = cj.学号 and cj.课程号 not in (select cj.课程号 from xs,cj where xs.学号 = cj.学号 and xs.姓名 = '程明')--5.查询每个专业年龄超过该专业平均年龄的学生的姓名和专业select xs1.姓名,xs1.专业from xs xs1where datediff(yy,xs1.出生时间,getdate()) &gt; (select avg(datediff(yy,xs2.出生时间,getdate())) from xs xs2 where xs1.专业 = xs2.专业)--6.查询每个专业每门课程的专业，课程号，课程名，选课人数，平均分和最高分select xs.专业,kc.课程号,kc.课程名,count(*) 选课人数,avg(cj.成绩) 平均分,max(cj.成绩) 最高分from xs,kc,cjwhere xs.学号 = cj.学号 and kc.课程号 = cj.课程号group by kc.课程号,kc.课程名,xs.专业--7.查询每个学生取得最高分的课程的课程号，课程名和成绩select cj.学号,kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.成绩 &gt;= all (select cj2.成绩 from cj cj2 where cj2.学号 = cj.学号)--8.查询每个专业年龄最高的学生的学号，姓名，专业和年龄select xs.学号,xs.姓名,xs.专业,datediff(yy,xs.出生时间,getdate()) 年龄from xswhere datediff(yy,xs.出生时间,getdate()) &gt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = xs.专业)--9.查询没有选修数据结构和操作系统的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.学号 not in (select cj.学号 from cj where cj.课程号 in (select kc.课程号 from kc where kc.课程名 = '数据结构' or kc.课程名 = '操作系统'))--10.查询网络工程专业年龄最小的学生的学号和姓名select xs.学号,xs.姓名from xswhere xs.专业 = '网络工程' and datediff(yy,xs.出生时间,getdate()) &lt;= all (select datediff(yy,xs2.出生时间,getdate()) from xs xs2 where xs2.专业 = '网络工程')--11.查询选课人数超过5人的课程的课程号，课程名和成绩select kc.课程号,kc.课程名,cj.成绩from kc,cjwhere kc.课程号 = cj.课程号 and cj.课程号 in (select cj2.课程号 from cj cj2 group by cj2.课程号 having count(cj2.学号) &gt; 5)--12.查询选修了全部课程的学生的学号和姓名（用两种方法实现）select xs.学号,xs.姓名from xswhere not exists (select * from kc where not exists (select * from cj where cj.学号 = xs.学号 and cj.课程号 = kc.课程号))select xs.学号,xs.姓名from xswhere xs.学号 in (select cj.学号 from cj group by cj.学号 having count(*) = (select count(*) from kc))--13.查询选课人数最多的课程号和课程名（包含并列）select cj.课程号,kc.课程名from kc,cjwhere kc.课程号 = cj.课程号group by cj.课程号,kc.课程名having count(*) &gt;= all (select count(*) from cj cj2 group by cj2.课程号)--14.查询选修了程明所选修的全部课程的学生的姓名select distinct xs.姓名from xs,cj where xs.学号 = cj.学号 and not exists (select * from cj cj2,xs xs2 where xs2.学号 = cj2.学号 and xs2.姓名 = '程明' and not exists (select * from cj cj3 where cj3.学号 = cj.学号 and cj 3.课程号 = cj2.课程号))--二．对罗斯文数据库完成一下查询--15.查询每个订单购买产品的数量和总金额，显示订单号，数量，总金额select [Order Details].OrderID,sum([Order Details].Quantity) 数量,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details]group by [Order Details].OrderID--16.查询每个员工在7月份处理订单的数量select count(Orders.OrderID) 订单数量from Orders right join Employees on (Employees.EmployeeID = Orders.EmployeeID)where month(Orders.OrderDate) = '07'group by Employees.EmployeeID--17.查询每个顾客的订单总数，显示顾客ID，订单总数select Customers.CustomerID,count(Orders.OrderID) 订单总数from Orders right join Customers on (Customers.CustomerID = Orders.CustomerID)group by Customers.CustomerID--18.查询每个顾客的订单总数和订单总金额select Customers.CustomerID,count(distinct Orders.OrderID) 订单总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from Orders right join Customers on Orders.CustomerID=Customers.CustomerID left join [Order Details] on Orders.OrderID=[Order Details].OrderIDgroup by Customers.CustomerID--19.查询每种产品的卖出总数和总金额select sum([Order Details].Quantity) 卖出总数,sum([Order Details].UnitPrice*[Order Details].Quantity*(1-[Order Details].Discount)) 总金额from [Order Details] right join Products on ([Order Details].ProductID = Products.ProductID)group by Products.ProductID--20.查询购买过全部商品的顾客的ID和姓名select Customers.CustomerID,Customers.ContactNamefrom Customerswhere not exists (select * from Products where not exists (select * from Orders,[Order Details] where Orders.OrderID = [Order Details].OrderID and Products.ProductID = [Order Details].ProductID and Customers.CustomerID = Orders.CustomerID))--三.对books数据库完成以下操作--21.查询各种类别的图书的类别和数量（包含目前没有图书的类别）select BookType.TypeName,count(BookInfo.TypeID) 数量from BookType left join BookInfo on (BookType.TypeID = BookInfo.TypeID)group by BookType.TypeName--22.查询借阅了‘数据库基础’的读者的卡编号和姓名select BorrowInfo.CardNo,CardInfo.Readerfrom BorrowInfo,CardInfo,BookInfowhere BorrowInfo.BookNo = BookInfo.BookNo and BorrowInfo.CardNo = CardInfo.CardNo and BookInfo.BookName = '数据库基础'--23.查询各个出版社的图书价格超过这个出版社图书的平均价格的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.Price &gt; (select avg(b1.Price) from BookInfo b1 where BookInfo.Publisher = b1.Publisher)--24.查询没有借过图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere CardInfo.CardNo not in (select BorrowInfo.CardNo from BorrowInfo)--25.查询借阅次数超过2次的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfo,BorrowInfowhere CardInfo.CardNo = BorrowInfo.CardNogroup by CardInfo.CardNo,CardInfo.Readerhaving count(BorrowInfo.CardNo) &gt; 2--26.查询借阅卡的类型为老师和研究生的读者人数select count(CardInfo.CardNo) 读者人数from CardType,CardInfowhere CardInfo.CTypeID = CardType.CTypeID and (CardType.TypeName = '教师' or CardType.TypeName = '研究生')--27.查询没有被借过的图书的编号和名称select BookInfo.BookNo,BookInfo.BookNamefrom BookInfowhere BookInfo.BookNo not in (select BorrowInfo.BookNo from BorrowInfo)--28.查询没有借阅过英语类型的图书的学生的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo,BorrowInfo,BookType,CardType where BookType.TypeName='英语' and CardType.TypeName = '学生' and CardType.CTypeID = CardInfo.CTypeID and BookType.TypeID=BookInfo.TypeID and BookInfo.BookNo=BorrowInfo.BookNo and BorrowInfo.CardNo=CardInfo.CardNo)--29.查询借阅了‘计算机应用’类别的‘数据库基础’课程的学生的编号读者以及该读者的借阅卡的类型select CardInfo.CardNo,CardType.TypeNamefrom CardInfo,CardType,BorrowInfowhere CardInfo.CTypeID = CardType.CTypeID and BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo in (select BookInfo.BookNo from BookInfo where BookInfo.BookName = '数据库基础')--30.查询借阅过了全部图书的读者的编号和姓名select CardInfo.CardNo,CardInfo.Readerfrom CardInfowhere not exists (select * from BookInfo where not exists (select * from BorrowInfo where BorrowInfo.CardNo = CardInfo.CardNo and BorrowInfo.BookNo = BookInfo.BookNo))--四．对商场数据库完成以下操作--Market (mno, mname, city)--Item (ino, iname, type, color)--Sales (mno, ino, price)--其中，market表示商场，它的属性依次为商场号、商场名和所在城市；item表示商品，它的属性依次为商品号、商品名、商品类别和颜色；sales表示销售，它的属性依次为商场号、商品号和售价。用SQL语句实现下面的查询要求：--1.列出北京各个商场都销售，且售价均超过10000 元的商品的商品号和商品名select item.ino,item.inamefrom itemwhere not exists (select * from sales,market where sales.mno = market.mno and market.city = '北京' and not exists (select * from sales s1 where s1.ino = item.ino and s1.mno = sales.mno and s1.price &gt; 10000))--2.列出在不同商场中最高售价和最低售价只差超过100 元的商品的商品号、最高售价和最低售价select sales.ino,max(sales.price) 最高售价,min(sales.price) 最低售价from salesgroup by sales.inohaving max(sales.price) - min(sales.price) &gt; 100--3.列出售价超过该商品的平均售价的各个商品的商品号和售价select sales.ino,sales.pricefrom saleswhere sales.price &gt; (select avg(s2.price) from sales s2 where s2.ino = sales.ino)--4.查询每个每个城市各个商场售价最高的商品的商场名，城市，商品号和商品名select market.mname,market.city,sales.ino,item.inamefrom market,sales,itemwhere market.mno = sales.mno and item.ino = sales.ino and sales.price &gt;= all (select s2.price from sales s2 where s2.mno = sales.mno)--5.查询销售商品数量最多的商场的商场号，商场名和城市select market.mno,market.mname,market.cityfrom market,saleswhere market.mno = sales.mnogroup by market.mno,market.mname,market.cityhaving count(sales.ino) &gt;= all (select count(s2.ino) from sales s2 group by s2.mno)--6.查询销售了冰箱和洗衣机的商场号，商场名和城市select distinct market.mno,market.mname,market.cityfrom market,saleswhere market.mno in (select s1.mno from sales s1 where s1.ino in (select item.ino from item where item.iname = '冰箱') and s1.mno in (select s2.mno from sales s2 where s2.ino in (select item.ino from item where item.iname = '洗衣机')))--7.查询所有商场都销售了的商品的商品号和商品名。（用两种方法实现）select item.ino,item.inamefrom itemwhere not exists (select * from market where not exists (select * from sales where sales.mno = market.mno and sales.ino = item.ino))select item.ino,item.inamefrom item,saleswhere item.ino = sales.inogroup by sales.ino, item.ino,item.inamehaving count(sales.mno) = (select count(market.mno) from market)]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验二]]></title>
    <url>%2F2019%2F10%2F22%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !=''--2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001'--3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%'--4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc--5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号--6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35--7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001')--8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs--9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs--10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%'--12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20--13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80--14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业--15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1)--16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5--17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc--18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号--19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别--20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业--21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/--22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%'--23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号)select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号)--24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002')--25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1)--二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1'--2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno--3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200--4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红')--5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400--6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验四]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[问题描述对一个稀疏矩阵进行转置要求用十字链表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef int ElemType;typedef struct OLNode&#123; int i, j; ElemType e; struct OLNode *right, *down;&#125;OLNode, *OLink;typedef struct CrossList&#123; OLink *rhead, *chead; int mu, nu, tu;&#125;CrossList, *pCrossList;void CreateSMatrix_OL(pCrossList M)&#123; //输入行数列数以及非零元个数 printf("请输入行数，列数，非零元素个数：\n"); scanf("%d%d%d", &amp;M-&gt;mu, &amp;M-&gt;nu, &amp;M-&gt;tu); if (M-&gt;tu * 20 &gt; M-&gt;mu * M-&gt;nu) printf("非稀疏矩阵，不建议使用此方法！\n"); //动态申请行和列指针数组 M-&gt;rhead = (OLink *)malloc(sizeof(OLink)*M-&gt;mu); if (M-&gt;rhead == NULL) return; M-&gt;chead = (OLink *)malloc(sizeof(OLink)*M-&gt;nu); if (M-&gt;chead == NULL)&#123; free(M-&gt;rhead); return; &#125; //初始化两个数组 int i, j; for (i = 1; i &lt;= M-&gt;mu; i++) M-&gt;rhead[i] = NULL; for (j = 1; j &lt;= M-&gt;nu; j++) M-&gt;chead[j] = NULL; //创建节点并连接到十字链表上 for (i = 1; i &lt;= M-&gt;tu; i++)&#123; OLink p = (OLink)malloc(sizeof(OLNode)); if (p == NULL) return; printf("请输入非零元素的行，列，值\n"); scanf("%d%d%d", &amp;p-&gt;i, &amp;p-&gt;j, &amp;p-&gt;e); p-&gt;down = NULL; p-&gt;right = NULL; //连接行 //如果该行并没有连接任何节点（NULL）或者该行连接的第一个节点的列值大于当前待连接的节点则直接将当前节点连接到该行第一个节点的位置 if (M-&gt;rhead[p-&gt;i] == NULL || M-&gt;rhead[p-&gt;i]-&gt;j &gt; p-&gt;j)&#123; p-&gt;right = M-&gt;rhead[p-&gt;i]; M-&gt;rhead[p-&gt;i] = p; &#125; //否则遍历该行找到合适的位置插入 else &#123; OLink q = M-&gt;rhead[p-&gt;i];//指向第一个节点，从第一个节点开始遍历 while (q-&gt;right != NULL &amp;&amp; q-&gt;right-&gt;j &lt; p-&gt;j)//遍历到前一个节点 q = q-&gt;right; p-&gt;right = q-&gt;right; q-&gt;right = p; &#125; //连接列 if (M-&gt;chead[p-&gt;j] == NULL || M-&gt;chead[p-&gt;j]-&gt;i &gt; p-&gt;i) &#123; p-&gt;down = M-&gt;chead[p-&gt;j]; M-&gt;chead[p-&gt;j] = p; &#125; else &#123; OLink pNodeTravel = M-&gt;chead[p-&gt;j]; while (pNodeTravel-&gt;down != NULL &amp;&amp; pNodeTravel-&gt;down-&gt;i &lt; p-&gt;i) pNodeTravel = pNodeTravel-&gt;down; p-&gt;down = pNodeTravel-&gt;down; pNodeTravel-&gt;down = p; &#125; &#125;&#125;void TransSMatrix_OL(CrossList M, CrossList *T)&#123; T-&gt;mu = M.nu; T-&gt;nu = M.mu; T-&gt;tu = M.tu; //Q的头节点的初始化 if (!(T-&gt;rhead = (OLink *)malloc((T-&gt;mu + 1) * sizeof(OLink)))) &#123;printf("内存空间申请失败！");return;&#125; if (!(T-&gt;chead = (OLink *)malloc((T-&gt;nu + 1) * sizeof(OLink)))) &#123; printf("内存空间申请失败！"); return; &#125; for (int i = 1; i &lt;= T-&gt;mu; i++) T-&gt;rhead[i] = NULL; for (int i = 1; i &lt;= T-&gt;nu; i++) T-&gt;chead[i] = NULL; if (!M.tu) return; OLink p, q, q_row, q_col; for (int i = 1; i &lt;= M.nu; i++)&#123; if (M.chead[i]) &#123; for (q = M.chead[i]; q;) &#123; if (!(p = (OLink)malloc(sizeof(OLNode))))&#123; printf("内存空间申请失败！"); return; &#125; p-&gt;i = q-&gt;j; p-&gt;j = q-&gt;i; p-&gt;e = q-&gt;e; p-&gt;right = p-&gt;down = NULL; q_row = T-&gt;rhead[i]; if (NULL == T-&gt;rhead[i]) T-&gt;rhead[i] = p; else &#123; while (q_row-&gt;right) q_row = q_row-&gt;right; q_row-&gt;right = p; &#125; q_col = T-&gt;chead[p-&gt;j]; if (T-&gt;chead[p-&gt;j] == NULL) T-&gt;chead[p-&gt;j] = p; else &#123; while (q_col-&gt;down) q_col = q_col-&gt;down; q_col-&gt;down = p; &#125; q = q-&gt;down; &#125; &#125; &#125; return;&#125;void OutputSMatrix_OL(pCrossList M, char s[])&#123; int i, j; OLink p; printf("----------------------\n"); printf("%s矩阵为：\n", s); for (i = 1; i &lt;= M-&gt;mu; i++)&#123; p = M-&gt;rhead[i]; for (j = 1; j &lt;= M-&gt;nu; j++)&#123; if (p != NULL &amp;&amp; p-&gt;j == j) &#123; printf("%d ", p-&gt;e); p = p-&gt;right; &#125; else printf("0 "); &#125; printf("\n"); &#125; printf("----------------------\n"); printf("\n"); return;&#125;int main()&#123; CrossList M, T; CreateSMatrix_OL(&amp;M); char s1[] = "原始"; OutputSMatrix_OL(&amp;M, s1); TransSMatrix_OL(M, &amp;T); char s2[] = "转置后"; OutputSMatrix_OL(&amp;T, s2); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验三]]></title>
    <url>%2F2019%2F10%2F21%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%89%2F</url>
    <content type="text"><![CDATA[问题描述对一个对称矩阵进行压缩及解压缩注意 压缩时： 第一步：完整地显示矩阵 第二步： 完整地显示一维数组 ——————————————————————————————————————— 解压缩时： 第一步：完整地显示一维数组 第二步：完整地显示矩阵 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define Matrix_Num 5void input_Matrix(int *Matrix)&#123; printf("输入方阵：\n"); for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; scanf("%d", &amp;Matrix[Matrix_Num * i + j]); &#125; &#125; printf("\n"); return;&#125;void show1D(int Compressed[])&#123; for (int i = 0; i &lt; Matrix_Num*(Matrix_Num + 1) / 2; i++) printf("%d ", Compressed[i]); printf("\n"); return;&#125;void show2D(int Matrix[])&#123; for (int i = 0; i &lt; Matrix_Num; i++) &#123; for (int j = 0; j &lt; Matrix_Num; j++) &#123; printf("%d ", Matrix[Matrix_Num*i + j]); &#125; printf("\n"); &#125; return;&#125;void compress(int Matrix[],int *Compressed)&#123; int n = 0; printf("您输入的方阵为：\n"); show2D(Matrix); printf("压缩后\n"); for (int i = 0; i &lt; Matrix_Num; i++) for (int j = 0; j &lt;= i; j++) Compressed[n++] = Matrix[Matrix_Num*i + j]; show1D(Compressed); printf("\n"); return;&#125;void uncompress_O1(int Compressed[],int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; int i, j; i = ceil(sqrt(2.25 + 2 * k) - 0.5); j = k - i * (i - 1) / 2; i--; Uncompressed[Matrix_Num*i + j] = Compressed[k]; Uncompressed[Matrix_Num*j + i] = Compressed[k]; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; int j = k - i * (i - 1) / 2 + 1; if (i &gt;= j &amp;&amp; j &gt;= 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; break; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;void uncompress_On2(int Compressed[], int *Uncompressed)&#123; printf("压缩方阵为：\n"); show1D(Compressed); printf("解压缩后\n"); for (int k = 0; k &lt; Matrix_Num * (Matrix_Num + 1) / 2; k++) &#123; for (int i = 1; i &lt;= Matrix_Num; i++) &#123; for (int j = 1; j &lt;= i; j++) &#123; if (k == i * (i - 1) / 2 + j - 1) &#123; Uncompressed[Matrix_Num*(i - 1) + (j - 1)] = Compressed[k]; Uncompressed[Matrix_Num*(j - 1) + (i - 1)] = Compressed[k]; &#125; &#125; &#125; &#125; show2D(Uncompressed); printf("\n"); return;&#125;int main()&#123; int M[Matrix_Num * Matrix_Num]; int C[Matrix_Num * (Matrix_Num + 1) / 2]; int U[Matrix_Num * Matrix_Num]; input_Matrix(M); compress(M, C); uncompress_O1(C, U); //uncompress_On(C, U); //uncompress_On2(C, U); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库实验一]]></title>
    <url>%2F2019%2F10%2F11%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188-- 一：对给定的xsgl数据库完成以下查询要求 ：--对xs表增加身份证号码属性列，要求是18位的字符类型alter table xs add 身份证号 char(18) --1.查询有直接先行课的课程的课号，课名和先行课号。select kc.课程号,kc.先行课号 from kcwhere kc.先行课号 !='' --2.查询先行课号是“J001”号课程的课号和课名select kc.课程号,kc.课程名from kcwhere kc.课程号 = 'J001' --3.查询所有的网络工程系姓李，张，王的同学的学号和姓名select xs.姓名,xs.学号from xswhere xs.专业 = '网络工程'and xs.姓名 like '[李，张，王]%' --4.查询不在网络工程和信息管理专业学习的学生的学号和姓名，系别，并对查询结果按照专业的升序和学号的降序排序select xs.学号,xs.姓名,xs.专业from xswhere xs.专业 not in ('网络工程','信息管理')order by xs.专业,xs.学号 desc --5.查询每门课不及格的学生的人数，显示课号和人数select cj.课程号,count(*) 人数from cjwhere cj.成绩 &lt; 60group by cj.课程号 --6.查询年龄不在30-35之间的网络工程系的学生的学号，姓名和年龄select xs.学号,xs.姓名,datediff(dd,出生时间,getdate())/365 as 年龄from xswhere datediff(dd,出生时间,getdate())/365 not between 30 and 35 --7.查询没有选修‘J001’号课程的学生的学号（注意去掉重复的元组）select distinct 学号from xswhere not exists(select *from cjwhere xs.学号 = cj.学号 and 课程号 = 'J001') --8.查询每个学生的学号，姓名，出生年份，并给出生年份起别名为chusheng select xs.学号,xs.姓名,datename(year,xs.出生时间) chushengfrom xs --9. 查询每个学生的学号，姓名和出生日期（出生日期根据身份证号码查询）select xs.学号,xs.姓名,datediff(yy,convert(varchar(10),cast(substring(xs.身份证号,7,8)as datetime),120),getdate()) 出生日期from xs --10.查询选修J001课程成绩排名第一的同学的学号和成绩select top 1 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --11. 查询所有名字中含有’明’或者’丽’的同学的学号，姓名select xs.学号,xs.姓名from xswhere xs.姓名 like '%[明,丽]%' --12. 查询信息管理专业年龄超过20岁的学生的人数select count(*)from xswhere xs.专业 = '信息管理' and datediff(dd,出生时间,getdate())/365 &gt; 20 --13. 查询平均成绩超过80分的课程的课程号和平均成绩select cj.课程号,avg(cj.成绩)from cjgroup by cj.课程号having avg(cj.成绩) &gt; 80 --14. 查询每个专业所有姓张的人数select xs.专业,count(*) 人数from xswhere xs.姓名 like '张%'group by xs.专业 --15. 查询各种姓氏的人数（假设没有复姓）select left(xs.姓名,1),count(left(xs.姓名,1)) 人数from xsgroup by left(xs.姓名,1) --16.查询选修课程超过5门的学生的学号和选课门数，以及平均成绩select cj.学号,count(cj.课程号) 选课门数,avg(cj.成绩) 平均成绩from cjgroup by cj.学号having count(cj.课程号) &gt; 5 --17. 查询选修‘J001’课程的成绩排名前五的学生的学号和成绩select top 5 cj.学号,cj.成绩from cjwhere cj.课程号 = 'J001'order by cj.成绩 desc --18.查询每个学生的最低分和选课门数select cj.学号,min(cj.成绩) 最低分,count(cj.课程号) 选课门数from cjgroup by cj.学号 --19. 查询各个专业各种性别的人数select xs.专业,xs.性别,count(xs.性别) 人数from xsgroup by xs.专业,xs.性别 --20.查询各个专业男生的人数select xs.专业,count(xs.性别) 人数from xswhere xs.性别 = '男'group by xs.专业 --21. 列出有二门以上课程（含两门）不及格的学生的学号及该学生的平均成绩；/*select cj.学号,avg(cj.成绩) 平均成绩from cjwhere cj.成绩 &lt; 60group by cj.学号having count(cj.成绩) &gt;= 2单表无法实现，因为where执行之后只剩不及格科目成绩求平均值*/ --22. 显示学号第五位或者第六位是1、2、3、4或者9的学生的学号、姓名、性别、年龄及专业；select xs.学号,xs.姓名,xs.性别,datediff(yy,xs.出生时间,getdate()) 年龄,xs.专业from xswhere xs.学号 like '____[1,2,3,4,9]%' or xs.学号 like '_____[1,2,3,4,9]%' --23. 显示选修课程数最多的学号及选修课程数最少的学号；select cj.学号from cjgroup by cj.学号having count(cj.课程号)&gt;=all(select count(cj.课程号)from cjgroup by cj.学号) select cj.学号from cjgroup by cj.学号having count(cj.课程号)&lt;=all(select count(cj.课程号)from cjgroup by cj.学号) --24. 查询选修了A001或者A002或者J001或者J002课程的学生的学号和课程号select cj.学号,cj.课程号from cjwhere cj.课程号 in ('A001','A002','J001','J002') --25. 查询姓名为两个字的不同姓氏的人数，输出姓氏，人数。select left(xs.姓名,1) 姓氏,count(left(xs.姓名,1)) 人数from xswhere len(xs.姓名) = 2group by left(xs.姓名,1) --二：对书上第二章课后习题的4的SPJ数据库各表查询： --1.求供应工程J1零件的供应商号码SNOselect SPJ.snofrom SPJwhere SPJ.jno='J1' --2.求查询每个工程使用不同供应商的零件的个数select SPJ.jno,SPJ.pno,sum(SPJ.qty) 个数from SPJgroup by SPJ.jno,SPJ.pno --3.求供应工程使用零件P3数量超过200的工程号JNOselect SPJ.jnofrom SPJwhere SPJ.pno = 'P3' and SPJ.qit &gt; 200 --4.求颜色为红色和蓝色的零件的零件号和名称select distinct pno, pnamefrom pwhere color in ('蓝','红') --5.求使用零件数量在200-400之间的工程号select SPJ.jnofrom SPJgroup by SPJ.jnohaving sum(SPJ.qty) between 200 and 400 --6.查询每种零件的零件号，以及使用该零件的工程数。select SPJ.pno,count(DISTINCT SPJ.jno) 工程数from SPJgroup by SPJ.pno]]></content>
      <categories>
        <category>Data Base Management System</category>
      </categories>
      <tags>
        <tag>Data Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验二]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[问题描述1.第一次实验的顺序实现2.顺序栈的实现3.N个元素的序列的所有出栈可能1.第一次实验1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define LIST_INIT_SIZE 100#define LISTINCREMENT 10#define ElemType int using namespace std;typedef struct &#123; ElemType *elem; int length; int listsize;&#125;SqList;void InitList_Sq(SqList &amp;L)&#123; L.elem = (ElemType*)malloc(LIST_INIT_SIZE * sizeof(ElemType)); L.length = 0; L.listsize = LIST_INIT_SIZE; return;&#125;int InputList_Sq(SqList &amp;L)&#123; ElemType n, temp; ElemType *p, *q; printf("请输入集合的元素个数：\n"); cin &gt;&gt; n; if (n &lt; 1 || n &gt; L.listsize) &#123; printf("输入有误\n"); return 0; &#125; if (L.length + n &gt;= L.listsize) &#123; L.elem = (ElemType*)realloc(L.elem, (L.length + n - L.listsize + LISTINCREMENT) * sizeof(ElemType)); L.listsize += (L.length + n - L.listsize + LISTINCREMENT); &#125; printf("请输入元素："); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q = &amp;(L.elem[i]); *q = temp; ++L.length; &#125; return 1;&#125;void MergeList_Sq(SqList La, SqList Lb, SqList &amp;Lc)&#123; ElemType *pa, *pb, *pc, *pa_last, *pb_last; pa = La.elem; pb = Lb.elem; Lc.listsize = Lc.length = La.length + Lb.length; pc = Lc.elem = (ElemType*)malloc(Lc.listsize * sizeof(ElemType)); pa_last = La.elem + La.length - 1; pb_last = Lb.elem + Lb.length - 1; while (pa &lt;= pa_last &amp;&amp; pb &lt;= pb_last) &#123; if (*pa &lt; *pb) *pc++ = *pa++; else *pc++ = *pb++; &#125; while (pa &lt;= pa_last)*pc++ = *pa++; while (pb &lt;= pb_last)*pc++ = *pb++; return;&#125;void Show_Sq(SqList L, char name)&#123; int cnt = 0; printf("集合%c中的元素为：",name); for (int i = 0; i &lt; L.length; i++) &#123; if (L.elem[i] != L.elem[i + 1]) &#123; cout &lt;&lt; L.elem[i] &lt;&lt; " "; cnt++; &#125; &#125; printf("去重后的元素个数为：%d\n", cnt); return;&#125;int main()&#123; SqList La, Lb, Lc; InitList_Sq(La); InitList_Sq(Lb); InitList_Sq(Lc); InputList_Sq(La); InputList_Sq(Lb); sort(La.elem, La.elem + La.length); sort(Lb.elem, Lb.elem + Lb.length); Show_Sq(La,'A'); Show_Sq(Lb,'B'); MergeList_Sq(La, Lb, Lc); Show_Sq(Lc,'C'); return 0;&#125; 2.顺序栈的实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;iostream&gt;#include&lt;cstdio&gt;#define STACK_INIT_SIZE 100#define STACKINCREMENT 10#define SElemType intusing namespace std;typedef struct &#123; SElemType *base; SElemType *top; int stacksize;&#125;SqStack;void InitStack(SqStack &amp;S)&#123; S.base = (SElemType*)malloc(STACK_INIT_SIZE * sizeof(SElemType)); S.top = S.base; S.stacksize = STACK_INIT_SIZE; return;&#125;int GetTop(SqStack S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *(S.top - 1); return 1;&#125;void Push(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top - S.base &gt;= S.stacksize) &#123; S.base = (SElemType*)realloc(S.base, (S.stacksize + STACKINCREMENT) * sizeof(SElemType)); S.top = S.base + S.stacksize; S.stacksize += STACKINCREMENT; &#125; *S.top++ = e; return;&#125;int Pop(SqStack &amp;S, SElemType &amp;e)&#123; if (S.top == S.base) return 0; e = *--S.top; return 1;&#125;void Show(SqStack S)&#123; printf("栈中现有元素为： |"); for (auto it = S.base; it &lt; S.top; it++) cout &lt;&lt; *it &lt;&lt; " "; printf("\n"); return;&#125;int main()&#123; int p; SElemType x; SqStack S; InitStack(S); while (1) &#123; printf("请选择您要进行的操作(1代表Push 2代表Pop 0代表退出) ："); scanf("%d", &amp;p); if (p == 1) &#123; printf("请输入要压入栈中的元素："); cin &gt;&gt; x; Push(S, x); Show(S); &#125; else if (p == 2) &#123; SElemType e = 0; if (Pop(S, e)) &#123; printf("出栈元素为："); cout &lt;&lt; e &lt;&lt; endl; Show(S); &#125; else printf("栈中没有元素\n"); &#125; else &#123; Show(S); break; &#125; &#125; return 0;&#125; 3.所有出栈可能12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int total, res, sta, n;int r[2005], s[2005];void dfs(int m) &#123; if (m == n + 1) &#123; //若所有元素都入过栈，输出当前出栈序列 total++; for (int i = 1; i &lt;= res; i++) cout &lt;&lt; r[i] &lt;&lt; ' '; for (int i = sta; i &gt; 0; i--) cout &lt;&lt; s[i] &lt;&lt; ' '; cout &lt;&lt; endl; return; &#125; if (sta &gt; 0) &#123; r[++res] = s[sta]; sta--; dfs(m); //栈顶元素出栈 s[++sta] = r[res]; res--; //回溯操作 &#125; s[++sta] = m; //当前元素入栈 dfs(m + 1); sta--; //回溯操作&#125;int main() &#123; printf("请输入元素个数："); scanf("%d", &amp;n); total = 0; res = 0; sta = 0; dfs(1); printf("共有%d种情况", total); return 0;&#125; 运行界面 顺序栈的实现 所有出栈可能]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构实验一]]></title>
    <url>%2F2019%2F09%2F23%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E4%B8%80%2F</url>
    <content type="text"><![CDATA[问题描述1.算法2.12.分别用链式和顺序表实现3.所涉及的基本操作全部用函数实现链式存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154#include&lt;iostream&gt;#include&lt;cstdio&gt; #include&lt;cstdlib&gt;#include&lt;cstring&gt; typedef struct LNode &#123; int data; LNode *next;&#125;LNode,*LinkList;void List_initialize(LinkList &amp;L, int n)&#123; LNode* p; L = (LNode*)malloc(sizeof(LNode)); L-&gt;next = NULL; for (int i = 0; i &lt; n; ++i)&#123; p = (LNode *)malloc(sizeof(LNode)); scanf("%d", &amp;p-&gt;data); p-&gt;next = L-&gt;next; L-&gt;next = p; &#125;&#125;bool compare(int a, int b)&#123; if (a == b) return true;&#125;void List_show(LNode *head)&#123; LNode *p = head-&gt;next; while (p != NULL)&#123; printf("%d ",p-&gt;data); p = p-&gt;next; &#125;&#125;int GetElem(LNode *L, int pos)&#123; LNode *p = L-&gt;next; for (int i = 0; i &lt; pos - 1; i++) p = p-&gt;next; return p-&gt;data;&#125;int Listlen(LNode *head)&#123; LNode *p = head-&gt;next; int len = 0; while (p)&#123; len++; p = p-&gt;next; &#125; return len;&#125;int List_insert(LinkList &amp;L, int i, int e)&#123; if (i &lt; 1) return 0; LNode *p = L; LNode *s; int j = 0; while (p &amp;&amp; j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p) return 0; s = (LNode *)malloc(sizeof(LNode)); s-&gt;data = e; s-&gt;next = p-&gt;next; p-&gt;next = s; return 1;&#125;LNode* List_only(LNode *head)&#123; LNode *p, *q, *s; p = head-&gt;next; while (p-&gt;next != NULL)&#123; q = p; while (q-&gt;next != NULL)&#123; if (q-&gt;next-&gt;data == p-&gt;data)&#123; s = q-&gt;next; q-&gt;next = s-&gt;next; free(s); &#125; else q = q-&gt;next; &#125; p = p-&gt;next; &#125; return head;&#125;void List_union(LinkList &amp;L1, LinkList L2)&#123; LinkList p, q, s; p = L1; q = L2; while (p-&gt;next != NULL) &#123; while (q-&gt;next != NULL) &#123; if (p-&gt;next-&gt;data == q-&gt;next-&gt;data) break; else q = q-&gt;next; &#125; if (q-&gt;next == NULL) &#123; s = (LinkList)malloc(sizeof(LNode)); s-&gt;data = p-&gt;next-&gt;data; s-&gt;next = NULL; q-&gt;next = s; &#125; p = p-&gt;next; q = L2; &#125;&#125;int main()&#123; int lena, lenb; LinkList la, lb; printf("请输入集合A的元素个数："); scanf("%d", &amp;lena); printf("请输入集合A元素："); List_initialize(la, lena); printf("原集合A："); List_show(la); printf("\n"); List_only(la); printf("集合去重后个数："); printf("%d",Listlen(la)); printf("\n"); printf("删除重复元素后的集合A为："); List_show(la); printf("\n"); printf("请输入集合B的元素个数："); scanf("%d", &amp;lenb); printf("请输入集合B元素："); List_initialize(lb, lenb); printf("集合B："); List_show(lb); printf("\n"); List_only(lb); printf("集合去重后个数："); printf("%d", Listlen(lb)); printf("\n"); printf("删除重复元素后的集合B为："); List_show(lb); printf("\n"); printf("A和B的并集为："); List_union(la, lb); List_only(la); List_show(la); return 0;&#125; 运行界面 顺序表存储123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[10000], b[10000];int lena, lenb;void arrayA_initialize()&#123; //输入集合A printf("请输入集合元素个数(小于10000)："); scanf("%d", &amp;lena); while (lena &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合A元素个数(小于10000)："); scanf("%d", &amp;lena); &#125; printf("请输入集合A元素："); int temp, cnta = 1; scanf("%d", &amp;a[0]); for (int i = 1; i &lt; lena; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == a[j]) flag = 0; &#125; if (flag) &#123; a[cnta] = temp; cnta++; &#125; &#125; lena = cnta; printf("数组A的长度最终为： %d\n", lena); printf("去重后的数组A为 ：\n"); for (int i = 0; i &lt; lena; i++) printf("%d ", a[i]); printf("\n");&#125;void arrayB_initialize()&#123; //输入集合B printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); while (lenb &gt;= 10000) &#123; printf("超出最大容量\n"); printf("请重新输入\n"); printf("请输入集合B元素个数(小于10000)："); scanf("%d", &amp;lenb); &#125; printf("请输入集合B元素："); int temp, cntb = 1; scanf("%d", &amp;b[0]); for (int i = 1; i &lt; lenb; i++) &#123; int flag = 1; scanf("%d", &amp;temp); for (int j = 0; j &lt; i; j++) &#123; //去重 if (temp == b[j]) flag = 0; &#125; if (flag) &#123; b[cntb] = temp; cntb++; &#125; &#125; lenb = cntb; printf("数组B的长度最终为： %d\n", lenb); printf("去重后的数组B为 ：\n"); for (int i = 0; i &lt; lenb; i++) printf("%d ", b[i]); printf("\n");&#125;int binarySearch(int a[], int b, int lena) &#123; int left = 0, right = lena - 1, mid; while (left &lt;= right)&#123; mid = (right + left) / 2; if (a[mid] == b) return 1; else if (a[mid] &gt; b)&#123; right = mid - 1; &#125; else left = mid + 1; &#125; return -1; &#125;void array_insert(int a[], int lena, int b[], int lenb)&#123; //将所有在数组B中但不在A中的数据元素插入到A中 int cnt = 0; for (int i = 0; i &lt; lenb; i++) &#123; if (binarySearch(a, b[i], lena) == -1) &#123; a[lena + cnt] = b[i]; cnt++; &#125; &#125; lena += cnt; printf("A与B合并后的集合为：\n"); for (int i = 0; i &lt; lena; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main()&#123; arrayA_initialize(); arrayB_initialize(); array_insert(a, lena, b, lenb); return 0;&#125; 运行界面]]></content>
      <categories>
        <category>Algorithms and Data Structures</category>
      </categories>
      <tags>
        <tag>Data Structure Experiment</tag>
      </tags>
  </entry>
</search>
